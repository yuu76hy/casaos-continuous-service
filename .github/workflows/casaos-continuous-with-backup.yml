name: CasaOS纯净部署（备份保留2份+自动清理 稳定精简版）
on:
  workflow_dispatch:
  repository_dispatch:
    types: [renew_casaos_snapshot]

jobs:
  casaos-deploy:
    runs-on: ubuntu-24.04
    timeout-minutes: 360
    env:
      WEBDAV_SNAPSHOT_DIR: "/z/Udu/CasaOS-Backup"
      PERSONAL_DATA_DIRS: "/var/lib/docker /etc/casaos /var/lib/casaos /DATA /root/.config"
      EXCLUDE_RULES: >-
        --exclude=*.log --exclude=*.tmp --exclude=*.cache 
        --exclude=/var/lib/docker/tmp --exclude=/var/lib/docker/containers/*/*.log 
        --exclude=/var/lib/docker/overlay2/*/tmp --exclude=/var/lib/docker/buildkit 
        --exclude=/var/lib/docker/image/*/layerdb/cache
        --exclude=/DATA/tmp --exclude=/DATA/cache --exclude=/DATA/logs
      WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
      WEBDAV_USER: ${{ secrets.WEBDAV_USER }}
      WEBDAV_PASSWORD: ${{ secrets.WEBDAV_PASSWORD }}
      ROOTS_PASSWORD: ${{ secrets.ROOTS_PASSWORD }}
      USER_PAT: ${{ secrets.USER_PAT }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      REPO: ${{ secrets.REPO }}
      KEEP_BACKUPS: 2
      TARGET_RUN_MINUTES: 15
      BACKUP_TIMEOUT_MINUTES: 60
      DEPLOY_TIMEOUT_MINUTES: 30

    steps:
      - name: 0-全局错误处理设置
        run: |
          set -e
          trap 'echo "❌ 流程在第 $LINENO 行失败，退出码: $?"' ERR
          trap 'echo "🔄 清理临时文件..." && sudo rm -rf /tmp/casaos_* /tmp/backup_* 2>/dev/null || true' EXIT
          echo "✅ 全局错误处理已设置"
          
      - name: 1-系统初始化+全域深度清理
        run: |
          set -e
          echo "===== 1-系统初始化+全域深度清理 ====="
          sudo apt update -y -qq
          sudo apt install -y curl wget jq tar gzip rclone lsof ca-certificates gnupg pv pigz psmisc -qq
          sudo apt remove -y docker* containerd* runc* 2>/dev/null || true
          sudo systemctl stop casaos 2>/dev/null || true
          sudo systemctl disable casaos 2>/dev/null || true
          sudo rm -f /etc/systemd/system/casaos.service /usr/lib/systemd/system/casaos.service 2>/dev/null || true
          sudo systemctl daemon-reload
          sudo rm -rf /usr/local/lib /usr/local/.ghcup /usr/local/julia* /usr/local/aws-* /usr/local/n 2>/dev/null || true
          sudo rm -rf /opt/hostedtoolcache /opt/actionarchivecache /opt/runner-cache /opt/microsoft /opt/google 2>/dev/null || true
          sudo DEBIAN_FRONTEND=noninteractive apt autoremove --purge -y 2>/dev/null || true
          sudo DEBIAN_FRONTEND=noninteractive apt clean 2>/dev/null || true
          sudo rm -rf /tmp/* /var/tmp/* ~/.cache/* /root/.cache/* /var/cache/apt/* 2>/dev/null || true
          sync && sudo sysctl -w vm.drop_caches=3 2>/dev/null || true
          echo "✅ 系统初始化+全域清理完成"
          
      - name: 2-官方纯净安装 Docker
        timeout-minutes: ${{ env.DEPLOY_TIMEOUT_MINUTES }}
        run: |
          set -e
          echo "===== 2-安装 Docker ====="
          curl -fsSL https://get.docker.com | sudo bash -s docker --mirror Aliyun
          sudo systemctl enable --now docker containerd && sleep 2
          docker --version && docker compose version
          sudo usermod -aG docker runner
          echo "✅ Docker 安装完成"
          
      - name: 3-官方纯净安装 CasaOS
        run: |
          set -e
          echo "===== 3-安装 CasaOS ====="
          curl -fsSL https://get.casaos.io | sudo bash
          sudo systemctl stop casaos 2>/dev/null || true
          echo "✅ CasaOS 安装完成"
          
      - name: 4-创建 roots 管理员+免密&Docker 权限
        run: |
          set -e
          echo "===== 4-配置管理员用户 ====="
          USER_NAME="roots"
          id -u "$USER_NAME" &>/dev/null || sudo useradd -m -s /bin/bash "$USER_NAME"
          [ -n "$ROOTS_PASSWORD" ] && echo "$USER_NAME:$ROOTS_PASSWORD" | sudo chpasswd || {
            RANDOM_PASS=$(openssl rand -base64 12)
            echo "$USER_NAME:$RANDOM_PASS" | sudo chpasswd
            echo "🔑 roots 随机密码：$RANDOM_PASS"
          }
          echo "$USER_NAME ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/"$USER_NAME" >/dev/null
          sudo chmod 0440 /etc/sudoers.d/"$USER_NAME"
          sudo usermod -aG docker "$USER_NAME"
          echo "✅ 管理员配置完成"
          
      - name: 5-WebDAV 配置+快照检测（调试版）
        run: |
          set -e
          echo "===== 5-WebDAV 环境初始化（调试） ====="
          
          # 显示当前配置状态
          echo "🔍 配置检查:"
          echo "  WEBDAV_URL 已设置: ${WEBDAV_URL:+是}"
          echo "  WEBDAV_USER 已设置: ${WEBDAV_USER:+是}"
          echo "  WEBDAV_PASSWORD 已设置: ${WEBDAV_PASSWORD:+是}"
          
          # 检查WebDAV配置是否完整
          if [ -z "$WEBDAV_URL" ] || [ -z "$WEBDAV_USER" ] || [ -z "$WEBDAV_PASSWORD" ]; then
            echo "❌ WebDAV 配置不完整："
            [ -z "$WEBDAV_URL" ] && echo "  - WEBDAV_URL 未设置"
            [ -z "$WEBDAV_USER" ] && echo "  - WEBDAV_USER 未设置"
            [ -z "$WEBDAV_PASSWORD" ] && echo "  - WEBDAV_PASSWORD 未设置"
            echo "⚠️ 跳过备份流程"
            echo "WEBDAV_AVAILABLE=false" >> "$GITHUB_ENV"
            exit 0
          fi
          
          # 测试WebDAV连接
          echo "测试WebDAV连接..."
          WEBDAV_CONNECT_TIMEOUT=30
          
          # 使用更详细的连接测试
          echo "尝试连接到WebDAV..."
          
          # 测试连接（使用HTTP状态码）
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout $WEBDAV_CONNECT_TIMEOUT --max-time $WEBDAV_CONNECT_TIMEOUT \
               -u "$WEBDAV_USER:$WEBDAV_PASSWORD" "$WEBDAV_URL" 2>/dev/null || echo "000")
          
          echo "HTTP状态码: $HTTP_CODE"
          
          # 检查HTTP状态码（2xx或3xx表示成功）
          if [[ "$HTTP_CODE" =~ ^[23][0-9][0-9]$ ]]; then
            echo "✅ WebDAV连接测试成功"
          else
            echo "❌ WebDAV连接测试失败，HTTP状态码: $HTTP_CODE"
            echo "WEBDAV_AVAILABLE=false" >> "$GITHUB_ENV"
            exit 0
          fi
          
          # 配置rclone
          ENCRYPTED_PASS=$(rclone obscure "$WEBDAV_PASSWORD")
          rclone config create mywebdav webdav url="$WEBDAV_URL" user="$WEBDAV_USER" pass="$ENCRYPTED_PASS" --config /home/runner/.rclone.conf >/dev/null
          sudo chmod 600 /home/runner/.rclone.conf
          
          # 测试rclone配置
          echo "测试rclone配置..."
          rclone mkdir mywebdav:$WEBDAV_SNAPSHOT_DIR --config /home/runner/.rclone.conf 2>/dev/null || {
            echo "⚠️ 无法创建目录，但可能已存在，继续..."
          }
          
          # 检查现有快照
          LATEST_SNAPSHOT=$(rclone ls mywebdav:$WEBDAV_SNAPSHOT_DIR --config /home/runner/.rclone.conf | grep casaos-full-snapshot | sed 's/^[0-9]\+ //' | sort -r | head -1)
          if [ -n "$LATEST_SNAPSHOT" ]; then
            echo "✅ 检测到快照：$LATEST_SNAPSHOT"
            echo "LATEST_SNAPSHOT=$LATEST_SNAPSHOT" >> "$GITHUB_ENV"
            echo "HAS_SNAPSHOT=true" >> "$GITHUB_ENV"
          else
            echo "✅ 无快照，纯净启动"
            echo "HAS_SNAPSHOT=false" >> "$GITHUB_ENV"
          fi
          
          echo "WEBDAV_AVAILABLE=true" >> "$GITHUB_ENV"
          echo "✅ WebDAV 初始化完成"
          
      - name: 5.1-WebDAV状态显示
        run: |
          echo "===== WebDAV状态 ====="
          echo "WEBDAV_AVAILABLE: ${WEBDAV_AVAILABLE:-未设置}"
          echo "HAS_SNAPSHOT: ${HAS_SNAPSHOT:-未设置}"
          echo "LATEST_SNAPSHOT: ${LATEST_SNAPSHOT:-无}"
          
      - name: 6-恢复历史快照+权限校正
        if: ${{ env.WEBDAV_AVAILABLE == 'true' && env.HAS_SNAPSHOT == 'true' }}
        run: |
          set -e
          echo "===== 6-恢复历史数据 ====="
          sudo systemctl stop docker containerd casaos 2>/dev/null || true
          sudo pkill -9 docker containerd casaos 2>/dev/null || true
          sudo rm -f /var/run/docker.pid /var/run/docker.sock.lock /var/run/containerd.pid 2>/dev/null || true
          sync && sleep 2
          sudo mkdir -p $PERSONAL_DATA_DIRS 2>/dev/null || true
          rclone cat mywebdav:$WEBDAV_SNAPSHOT_DIR/$LATEST_SNAPSHOT --config /home/runner/.rclone.conf | sudo tar -xzf - -C / --overwrite --preserve-permissions $PERSONAL_DATA_DIRS
          sudo chown -R root:root $PERSONAL_DATA_DIRS
          sudo chmod -R 755 /etc/casaos /DATA /root/.config
          sudo chmod -R 700 /var/lib/casaos /var/lib/docker
          echo "✅ 数据恢复完成"
          
      - name: 7-启动 Docker & CasaOS 核心服务
        run: |
          set -e
          echo "===== 7-启动核心服务 ====="
          sudo fuser -k 80/tcp 443/tcp 2>/dev/null || true
          sudo mkdir -p /run/docker 2>/dev/null || true
          sudo systemctl daemon-reload
          sudo systemctl enable --now docker containerd && sleep 3
          sudo systemctl enable --now casaos && sleep 4
          echo "✅ 服务启动完成，CasaOS 可访问"
          
      - name: 8-Tailscale 组网（可选）
        run: |
          set -e
          if [ -z "$TAILSCALE_AUTH_KEY" ]; then
            echo "⚠️ Tailscale 未配置，跳过"
            exit 0
          fi
          echo "===== 8-Tailscale 组网 ====="
          curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/noble.noarmor.gpg | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
          echo "deb [signed-by=/usr/share/keyrings/tailscale-archive-keyring.gpg] https://pkgs.tailscale.com/stable/ubuntu noble main" | sudo tee /etc/apt/sources.list.d/tailscale.list >/dev/null
          sudo apt update -y -qq && sudo apt install -y tailscale -qq
          sudo systemctl enable --now tailscaled && sleep 2
          sudo tailscale up --authkey="$TAILSCALE_AUTH_KEY" --hostname="CasaOS-$(hostname | cut -c1-6)" --accept-routes
          TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null)
          echo "✅ Tailscale 组网成功，内网IP：${TAILSCALE_IP:-未获取}"
          
      - name: 9-延时校准（智能轮询等待，满15分钟再备份）
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          set -e
          echo "===== 9-延时校准（智能轮询等待） ====="
          
          # 记录开始时间
          START_TIMESTAMP=$(date +%s)
          TARGET_SECONDS=$((TARGET_RUN_MINUTES * 60))
          
          echo "开始时间: $(date -d @$START_TIMESTAMP '+%Y-%m-%d %H:%M:%S')"
          echo "目标运行时间: $TARGET_RUN_MINUTES 分钟 ($TARGET_SECONDS 秒)"
          
          # 已经运行的时间（秒）
          ELAPSED_TIME=$(( $(date +%s) - START_TIMESTAMP ))
          
          # 计算需要等待的时间
          if [ $ELAPSED_TIME -lt $TARGET_SECONDS ]; then
            REMAINING_TIME=$((TARGET_SECONDS - ELAPSED_TIME))
            echo "当前已运行: $ELAPSED_TIME 秒"
            echo "需要继续等待: $REMAINING_TIME 秒"
            
            # 智能轮询等待：每30秒输出一次进度，避免长时间无输出
            while [ $REMAINING_TIME -gt 0 ]; do
              # 每次等待30秒或剩余时间中的较小值
              SLEEP_TIME=$((REMAINING_TIME > 30 ? 30 : REMAINING_TIME))
              echo "等待 ${SLEEP_TIME} 秒 (剩余: ${REMAINING_TIME} 秒)..."
              sleep $SLEEP_TIME
              
              # 更新已运行时间和剩余时间
              ELAPSED_TIME=$(( $(date +%s) - START_TIMESTAMP ))
              REMAINING_TIME=$((TARGET_SECONDS - ELAPSED_TIME))
              
              # 每5分钟输出一次详细状态
              if [ $((ELAPSED_TIME % 300)) -lt 30 ]; then
                echo "⏰ 已运行 $((ELAPSED_TIME / 60)) 分钟 $((ELAPSED_TIME % 60)) 秒"
              fi
            done
          else
            echo "✅ 已满足最小运行时间，跳过等待"
          fi
          
          TOTAL_ELAPSED=$(( $(date +%s) - START_TIMESTAMP ))
          echo "✅ 总运行时间: $((TOTAL_ELAPSED / 60)) 分钟 $((TOTAL_ELAPSED % 60)) 秒，准备备份"
          
      - name: 10-停止所有服务（备份前置，无文件占用）
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          set -e
          echo "===== 10-停止所有服务（备份安全） ====="
          sudo systemctl stop casaos docker containerd tailscaled 2>/dev/null || true
          sudo pkill -9 -f "casaos|docker|containerd|tailscaled" 2>/dev/null || true
          sudo rm -f /var/run/docker.pid /var/run/docker.sock.lock /var/run/containerd.pid 2>/dev/null || true
          sync && sleep 5
          echo "✅ 所有服务已停止，可安全备份"
          
      - name: 11-0 备份前检查
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          set -e
          echo "===== 11-0 磁盘空间检查 ====="
          FREE_SPACE=$(df -h /tmp | awk 'NR==2 {print $4}')
          echo "临时目录可用空间: $FREE_SPACE"
          
          # 估算需要的最小空间（原始数据的1.5倍）
          ESTIMATED_SIZE=$(sudo du -sc $PERSONAL_DATA_DIRS 2>/dev/null | tail -1 | awk '{print $1}')
          ESTIMATED_SIZE_MB=$((ESTIMATED_SIZE / 1024))
          MIN_SPACE_NEEDED=$((ESTIMATED_SIZE_MB * 150 / 100))
          
          echo "估算备份需要: ${ESTIMATED_SIZE_MB}MB，建议最少: ${MIN_SPACE_NEEDED}MB"
          
          # 检查/tmp空间
          TMP_FREE_MB=$(df -m /tmp | awk 'NR==2 {print $4}')
          if [ $TMP_FREE_MB -lt $MIN_SPACE_NEEDED ]; then
            echo "⚠️ 临时空间不足，清理/tmp目录..."
            sudo rm -rf /tmp/casaos_* /tmp/backup_* /tmp/*.tar.gz 2>/dev/null || true
          fi
          echo "✅ 磁盘空间检查完成"
          
      - name: 11-1 全量备份-打包压缩
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        id: backup_pack
        timeout-minutes: ${{ env.BACKUP_TIMEOUT_MINUTES }}
        run: |
          set -e
          echo "===== 11-1 打包压缩核心数据 ====="
          
          SNAPSHOT_NAME="casaos-full-snapshot-$(date +%Y%m%d-%H%M%S).tar.gz"
          SNAPSHOT_PATH="/tmp/$SNAPSHOT_NAME"
          echo "SNAPSHOT_NAME=$SNAPSHOT_NAME" >> "$GITHUB_ENV"
          echo "SNAPSHOT_PATH=$SNAPSHOT_PATH" >> "$GITHUB_ENV"
          
          # 打包函数
          pack_data() {
            local attempt=$1
            echo "第${attempt}次打包尝试..."
            
            # 使用pv显示进度
            sudo tar -cPf - $EXCLUDE_RULES $PERSONAL_DATA_DIRS 2>/dev/null | \
              sudo pv -p -t -e -b -a | \
              sudo pigz -p 4 > $SNAPSHOT_PATH
            
            # 验证打包文件
            if [ -f "$SNAPSHOT_PATH" ] && sudo gzip -t "$SNAPSHOT_PATH" 2>/dev/null; then
              FILE_SIZE=$(du -h "$SNAPSHOT_PATH" | cut -f1)
              echo "✅ 打包成功！文件大小: $FILE_SIZE"
              return 0
            else
              echo "❌ 打包文件验证失败"
              return 1
            fi
          }
          
          # 最多重试3次
          for i in {1..3}; do
            if pack_data $i; then
              echo "pack_success=true" >> "$GITHUB_OUTPUT"
              break
            elif [ $i -lt 3 ]; then
              RETRY_DELAY=$((10 * i))
              echo "⏳ 等待${RETRY_DELAY}秒后重试..."
              sleep $RETRY_DELAY
            else
              echo "❌ 打包失败，已达到最大重试次数"
              exit 1
            fi
          done
          
      - name: 11-2 全量备份-上传WebDAV
        if: ${{ env.WEBDAV_AVAILABLE == 'true' && steps.backup_pack.outputs.pack_success == 'true' }}
        id: backup_upload
        timeout-minutes: ${{ env.BACKUP_TIMEOUT_MINUTES }}
        run: |
          set -euo pipefail
          echo "===== 11-2 上传快照到WebDAV ====="
          
          # 环境变量校验
          if [ -z "$SNAPSHOT_NAME" ] || [ -z "$SNAPSHOT_PATH" ] || [ -z "$WEBDAV_SNAPSHOT_DIR" ]; then
            echo "❌ 错误：必要环境变量未定义"
            exit 1
          fi
          echo "✅ 环境变量校验通过"
          
          # 上传函数
          upload_data() {
            echo "开始上传：$SNAPSHOT_NAME"
            
            rclone copy \
              "$SNAPSHOT_PATH" \
              "mywebdav:$WEBDAV_SNAPSHOT_DIR/" \
              --config /home/runner/.rclone.conf \
              --transfers 2 \
              --multi-thread-streams 8 \
              --chunk-size 128M \
              --buffer-size 64M \
              --max-redirects 10 \
              --disable-http2 \
              --contimeout 10m \
              --retries 5 \
              --low-level-retries 15 \
              --timeout 30m \
              --stats 10s \
              --stats-one-line \
              --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" \
              --partial-suffix .rclone.part \
              --no-fast-list
            
            # 完整性验证
            echo "开始验证上传完整性..."
            local local_size=$(stat -c %s "$SNAPSHOT_PATH")
            local remote_size=$(rclone size --json "mywebdav:$WEBDAV_SNAPSHOT_DIR/$SNAPSHOT_NAME" --config /home/runner/.rclone.conf | jq -r '.bytes')
            
            if [ -z "$remote_size" ] || [ "$local_size" != "$remote_size" ]; then
              echo "⚠️ 验证失败：本地大小 $local_size，远程大小 ${remote_size:-未获取}"
              return 1
            fi
            echo "✅ 上传完整性验证通过"
            
            # 清理本地文件
            if [ -f "$SNAPSHOT_PATH" ]; then
              rm -f "$SNAPSHOT_PATH"
              echo "✅ 本地快照已清理"
            fi
            
            return 0
          }
          
          # 双层重试
          if ! upload_data; then
            echo "⚠️ 首次上传失败，10分钟后重试..."
            sleep 600
            if ! upload_data; then
              echo "❌ 上传最终失败"
              exit 1
            fi
          fi
          
          echo "upload_success=true" >> "$GITHUB_OUTPUT"
          
      - name: 11-3 备份后处理-清理旧备份+触发续跑
        if: ${{ env.WEBDAV_AVAILABLE == 'true' && steps.backup_upload.outputs.upload_success == 'true' }}
        run: |
          set -e
          echo "===== 11-3 备份后处理 ====="
          BACKUPS=$(rclone ls mywebdav:$WEBDAV_SNAPSHOT_DIR --config /home/runner/.rclone.conf | grep casaos-full-snapshot | sed 's/^[0-9]\+ //' | sort -r)
          if [ $(echo "$BACKUPS" | wc -l) -gt $KEEP_BACKUPS ]; then
            echo "清理旧备份（保留最新$KEEP_BACKUPS份）："
            echo "$BACKUPS" | tail -n +$((KEEP_BACKUPS+1)) | xargs -I {} echo "删除：{}"
            echo "$BACKUPS" | tail -n +$((KEEP_BACKUPS+1)) | xargs -I {} rclone delete mywebdav:$WEBDAV_SNAPSHOT_DIR/{} --config /home/runner/.rclone.conf 2>/dev/null
            echo "✅ 旧备份清理完成"
          else
            echo "✅ 当前备份数≤$KEEP_BACKUPS，无需清理"
          fi
          if [ -n "$USER_PAT" ] && [ -n "$REPO" ]; then
            echo "📌 触发下一轮自动续跑..."
            curl -s -f -X POST \
              -H "Authorization: token $USER_PAT" \
              -H "Content-Type: application/json" \
              https://api.github.com/repos/$REPO/dispatches \
              -d '{"event_type":"renew_casaos_snapshot"}' >/dev/null 2>&1
            if [ $? -eq 0 ]; then
              echo "✅ 自动续跑触发成功（仅一次）"
            else
              echo "⚠️ 自动续跑触发失败"
            fi
          fi
          
      - name: 12-健康检查
        run: |
          echo "===== 12-服务健康检查 ====="
          
          # 检查Docker服务
          if systemctl is-active --quiet docker; then
            echo "✅ Docker 服务运行正常"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || true
          else
            echo "⚠️ Docker 服务未运行"
          fi
          
          # 检查CasaOS服务
          if systemctl is-active --quiet casaos; then
            echo "✅ CasaOS 服务运行正常"
            CASAOS_IP=$(hostname -I | awk '{print $1}' 2>/dev/null || echo "localhost")
            echo "CasaOS访问地址: http://$CASAOS_IP:80"
          else
            echo "⚠️ CasaOS 服务未运行"
          fi
          
          # 检查磁盘使用情况
          echo "磁盘使用情况:"
          df -h / /tmp /DATA 2>/dev/null || true
          
      - name: 13-敏感清理+流程完结
        if: ${{ always() }}
        run: |
          set -e
          echo "===== 13-清理+完结 ====="
          sudo rm -rf /tmp/* /home/runner/.rclone.conf /etc/sudoers.d/roots 2>/dev/null || true
          sudo apt autoremove -y -qq && sudo apt clean -y -qq
          sudo rm -rf /var/cache/apt/* 2>/dev/null || true
          echo "✅ 敏感信息清理完成"
          echo "🎉 CasaOS 部署+备份全流程完成"
          echo "🔚 当前流程结束，等待下一次调度"