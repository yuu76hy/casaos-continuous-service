# CasaOS 纯净部署（生产级｜备份恢复全加固）- 最终完善版
# 已修复：tar参数顺序、权限漏洞、临时目录属主、错误屏蔽、恢复校验、Docker组权限等所有问题
# 完整可直接运行，保留原有所有生产级特性（双备份模式、自动续跑、系统加固、垃圾清理）

name: CasaOS纯净部署（生产级｜备份恢复全加固）
on:
  workflow_dispatch:
  repository_dispatch:
    types: [renew_casaos_snapshot]

jobs:
  casaos-deploy:
    runs-on: ubuntu-24.04
    timeout-minutes: 720
    env:
      # 可配置参数（调整排除规则，确保关键文件不被排除）
      LOCAL_MOUNT_POINT: "/op"
      WEBDAV_SNAPSHOT_DIR: "/z/Udu/CasaOS-Backup"
      PERSONAL_DATA_DIRS: "/var/lib/docker /etc/casaos /var/lib/casaos /DATA /root/.config"
      # 排除规则：移除可能误排除关键文件的规则
      EXCLUDE_RULES: >-
        --exclude=*.log --exclude=*.tmp --exclude=*.cache --exclude=/var/lib/docker/tmp --exclude=/var/lib/docker/containers/*/*.log --exclude=/var/lib/docker/overlay2/*/tmp --exclude=/DATA/tmp --exclude=/DATA/cache --exclude=/DATA/logs
      KEEP_BACKUPS: 2
      SNAPSHOT_MD5_SUFFIX: ".md5"
      ZSTD_LEVEL: "-2"
      RCLONE_TRANSFERS: 8
      RCLONE_RETRIES: 10
      RCLONE_TIMEOUT: "2h"
      RCLONE_STATS: "30s"
      TARGET_RUN_MINUTES: 5
      MAX_SNAPSHOT_SIZE_GB: 50
      # 密钥配置（从GitHub Secrets读取）
      WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
      WEBDAV_USER: ${{ secrets.WEBDAV_USER }}
      WEBDAV_PASSWORD: ${{ secrets.WEBDAV_PASSWORD }}
      ROOTS_PASSWORD: ${{ secrets.ROOTS_PASSWORD }}
      USER_PAT: ${{ secrets.USER_PAT }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      REPO: ${{ secrets.REPO }}

    steps:
      - name: 1-【初始化】系统与Docker部署（安全+容错）
        run: |
          set -e
          trap 'echo "⚠️ 脚本中断，清理资源"; sudo rm -f /etc/sudoers.d/roots 2>/dev/null' EXIT
          
          echo "📌 工作流启动时间：$(date '+%Y-%m-%d %H:%M:%S')"
          echo "WORKFLOW_START_TIMESTAMP=$(date +%s)" >> "$GITHUB_ENV"
          
          # 安装基础依赖
          sudo DEBIAN_FRONTEND=noninteractive apt update -y -qq
          sudo DEBIAN_FRONTEND=noninteractive apt install -y curl wget jq tar gzip rclone lsof ca-certificates gnupg zstd davfs2 bc -qq
          sudo apt install -y zstd --upgrade -qq
          
          # 清理旧Docker残留
          sudo systemctl stop docker containerd 2>/dev/null || true
          sudo apt remove -y docker* containerd* runc* 2>/dev/null || true
          sudo rm -rf /var/lib/docker /var/lib/containerd /etc/docker 2>/dev/null || true
          sudo apt autoremove -y -qq && sudo apt clean -y -qq
          
          # Docker安装（5次重试+指数退避）
          INSTALL_RETRY=5
          RETRY_DELAY=30
          while [ $INSTALL_RETRY -gt 0 ]; do
            if curl -fsSL https://get.docker.com | sudo bash -s docker --mirror Aliyun; then
              break
            fi
            INSTALL_RETRY=$((INSTALL_RETRY-1))
            echo "⚠️ Docker安装失败，剩余重试次数：$INSTALL_RETRY，$RETRY_DELAY秒后重试"
            sleep $RETRY_DELAY
            RETRY_DELAY=$((RETRY_DELAY * 2))
          done
          [ $INSTALL_RETRY -eq 0 ] && { echo "❌ Docker安装失败" && exit 1; }
          
          # 启动并验证Docker+containerd
          sudo systemctl enable --now docker containerd
          sudo usermod -aG docker runner
          if ! docker info >/dev/null 2>&1 || ! sudo systemctl is-active --quiet containerd; then
            echo "❌ Docker/containerd启动失败" && exit 1
          fi
          echo "✅ Docker+containerd安装成功"

      - name: 2-【配置】管理员与空间校验（安全优化）
        run: |
          set -e
          trap 'sudo rm -f /etc/sudoers.d/roots 2>/dev/null' EXIT
          
          USER_NAME="roots"
          id -u "$USER_NAME" &>/dev/null || sudo useradd -m -s /bin/bash "$USER_NAME"
          [ -n "$ROOTS_PASSWORD" ] && echo "$USER_NAME:$ROOTS_PASSWORD" | sudo chpasswd
          
          # 临时免密sudo
          echo "$USER_NAME ALL=(ALL) NOPASSWD:SETENV: ALL" | sudo tee -a /etc/sudoers.d/"$USER_NAME" >/dev/null
          sudo chmod 0440 /etc/sudoers.d/"$USER_NAME"
          sudo usermod -aG docker "$USER_NAME"
          
          # /tmp空间校验（字节级）
          TMP_FREE=$(df -P -B 1 /tmp | awk 'NR>1 {print $4}')
          TMP_FREE_GB=$(echo "$TMP_FREE / 1024 / 1024 / 1024" | bc -l)
          if (( $(echo "$TMP_FREE_GB < 15" | bc -l) )); then
            echo "❌ /tmp空间不足15G，当前可用：$TMP_FREE_GB G" && exit 1
          fi
          echo "✅ /tmp空间校验通过"
          
          sudo rm -f /etc/sudoers.d/"$USER_NAME"
          echo "✅ 管理员配置完成"

      - name: 3-【备份模式】Rclone优先+挂载兜底（强校验）
        run: |
          set -e
          sudo mkdir -p "${LOCAL_MOUNT_POINT}" && sudo chmod 700 "${LOCAL_MOUNT_POINT}" && sudo chown runner:runner "${LOCAL_MOUNT_POINT}"
          
          if [ -z "$WEBDAV_URL" ] || [ -z "$WEBDAV_USER" ] || [ -z "$WEBDAV_PASSWORD" ]; then
            echo "USE_MOUNT=false" >> "$GITHUB_ENV"
            echo "USE_RCLONE=false" >> "$GITHUB_ENV"
            echo "WEBDAV_AVAILABLE=false" >> "$GITHUB_ENV"
            echo "⚠️ WebDAV配置不完整，备份功能禁用"
            exit 0
          fi
          
          # Rclone配置
          RCLONE_OK=false
          RCLONE_CONFIG="$HOME/.rclone.conf"
          rm -f "$RCLONE_CONFIG" 2>/dev/null || true
          ENCRYPTED_PASS=$(rclone obscure "$WEBDAV_PASSWORD")
          rclone config create mywebdav webdav url="$WEBDAV_URL" user="$WEBDAV_USER" pass="$ENCRYPTED_PASS" --config "$RCLONE_CONFIG" --quiet
          sudo chmod 600 "$RCLONE_CONFIG"
          
          # Rclone连通性校验
          RCLONE_RETRY=3
          while [ $RCLONE_RETRY -gt 0 ]; do
            if rclone mkdir mywebdav:${WEBDAV_SNAPSHOT_DIR} --config "$RCLONE_CONFIG" --quiet && rclone ls mywebdav:${WEBDAV_SNAPSHOT_DIR} --config "$RCLONE_CONFIG" --quiet >/dev/null; then
              RCLONE_OK=true
              break
            fi
            RCLONE_RETRY=$((RCLONE_RETRY-1))
            sleep 10
          done
          [ "$RCLONE_OK" = true ] && echo "✅ Rclone模式初始化成功"
          
          # 挂载模式兜底
          MOUNT_OK=false
          if [ "$RCLONE_OK" = false ]; then
            echo "${WEBDAV_URL} ${WEBDAV_USER} ${WEBDAV_PASSWORD}" | sudo tee /etc/davfs2/secrets >/dev/null
            sudo chmod 600 /etc/davfs2/secrets
            if sudo mount -t davfs "${WEBDAV_URL}" "${LOCAL_MOUNT_POINT}" -o uid=runner,gid=runner,file_mode=600,dir_mode=700 --quiet; then
              sleep 3
              if mount | grep -q "${LOCAL_MOUNT_POINT}"; then
                sudo mkdir -p "${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}" && sudo chmod 700 "${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}"
                MOUNT_OK=true
                echo "✅ 挂载模式初始化成功"
              fi
            fi
            sudo rm -f /etc/davfs2/secrets
          fi
          
          # 环境变量赋值
          if [ "$RCLONE_OK" = true ] || [ "$MOUNT_OK" = true ]; then
            echo "WEBDAV_AVAILABLE=true" >> "$GITHUB_ENV"
          else
            echo "WEBDAV_AVAILABLE=false" >> "$GITHUB_ENV"
          fi
          echo "USE_RCLONE=$RCLONE_OK" >> "$GITHUB_ENV"
          echo "USE_MOUNT=$MOUNT_OK" >> "$GITHUB_ENV"
          echo "RCLONE_CONFIG=$RCLONE_CONFIG" >> "$GITHUB_ENV"

      - name: 4-【快照】历史快照检测（Rclone优先）
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          set -e
          LATEST_SNAPSHOT=""
          
          if [ "${USE_RCLONE}" = true ]; then
            BACKUPS=$(rclone ls mywebdav:${WEBDAV_SNAPSHOT_DIR} --config "${RCLONE_CONFIG}" --quiet 2>/dev/null | grep "casaos-full-snapshot.*\.tar\.zst" | sort -r)
            [ -n "$BACKUPS" ] && LATEST_SNAPSHOT=$(echo "$BACKUPS" | head -1 | awk '{print $2}')
          fi
          
          if [ -z "$LATEST_SNAPSHOT" ] && [ "${USE_MOUNT}" = true ]; then
            REMOTE_DIR="${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}"
            BACKUPS=$(ls -t "${REMOTE_DIR}"/casaos-full-snapshot*.tar.zst 2>/dev/null)
            [ -n "$BACKUPS" ] && LATEST_SNAPSHOT=$(basename "$(echo "$BACKUPS" | head -1)")
          fi
          
          if [ -n "$LATEST_SNAPSHOT" ]; then
            echo "LATEST_SNAPSHOT=$LATEST_SNAPSHOT" >> "$GITHUB_ENV"
            echo "LATEST_SNAPSHOT_MD5=${LATEST_SNAPSHOT}${SNAPSHOT_MD5_SUFFIX}" >> "$GITHUB_ENV"
            echo "HAS_SNAPSHOT=true" >> "$GITHUB_ENV"
            echo "✅ 找到最新快照: $LATEST_SNAPSHOT"
          else
            echo "HAS_SNAPSHOT=false" >> "$GITHUB_ENV"
            echo "⚠️ 无历史快照，执行全新部署"
          fi

      - name: 5-【部署】CasaOS纯净安装（恢复原安装方式，去掉sha256校验）
        run: |
          set -e
          trap 'echo "⚠️ 安装中断，清理残留"; sudo rm -f /tmp/install-casaos.sh 2>/dev/null' EXIT
          
          # 彻底清理旧CasaOS残留
          sudo systemctl stop casaos 2>/dev/null || true
          sudo systemctl disable casaos 2>/dev/null || true
          sudo rm -rf /etc/casaos /var/lib/casaos /usr/local/casaos /opt/casaos /usr/bin/casaos /usr/sbin/casaos /etc/systemd/system/casaos*
          sudo systemctl daemon-reload
          
          # 补装CasaOS依赖
          CASAOS_DEPENDS=("wget" "curl" "smartmontools" "parted" "ntfs-3g" "net-tools" "samba" "cifs-utils" "mergerfs" "unzip")
          for pkg in "${CASAOS_DEPENDS[@]}"; do
            if apt-cache show "$pkg" >/dev/null 2>&1; then
              sudo DEBIAN_FRONTEND=noninteractive apt install -y "$pkg" -qq --no-upgrade
              echo "✅ 安装依赖：$pkg"
            else
              echo "⚠️ 依赖$pkg未找到，跳过"
            fi
          done
          
          # 恢复原安装方式：直接下载并执行脚本（去掉sha256校验）
          echo "ℹ️ 安装CasaOS（原方式，3次重试）"
          INSTALL_RETRY=3
          RETRY_DELAY=30
          INSTALL_LOG="$GITHUB_WORKSPACE/casaos_install.log"
          while [ $INSTALL_RETRY -gt 0 ]; do
            curl -fsSL https://get.casaos.io -o /tmp/install-casaos.sh
            if sudo bash -x /tmp/install-casaos.sh > "$INSTALL_LOG" 2>&1; then
              echo "✅ 第$((4 - INSTALL_RETRY))次安装成功"
              break
            fi
            INSTALL_RETRY=$((INSTALL_RETRY-1))
            echo "⚠️ CasaOS安装失败，剩余重试次数：$INSTALL_RETRY，日志已保存到$INSTALL_LOG"
            cat "$INSTALL_LOG" | tail -20
            rm -f /tmp/install-casaos.sh
            sleep $RETRY_DELAY
            RETRY_DELAY=$((RETRY_DELAY * 2))
          done
          [ $INSTALL_RETRY -eq 0 ] && { echo "❌ CasaOS安装失败，完整日志：$(cat "$INSTALL_LOG")" && exit 1; }
          
          # 停止服务+验证安装
          sudo systemctl stop casaos 2>/dev/null || true
          CASAOS_PATHS=("/usr/local/casaos/casaos" "/usr/bin/casaos" "/usr/sbin/casaos" "/opt/casaos/casaos")
          INSTALL_PATH=""
          for path in "${CASAOS_PATHS[@]}"; do
            if [ -f "$path" ] && [ -x "$path" ] && [ -s "$path" ]; then
              INSTALL_PATH="$path"
              break
            fi
          done
          [ -z "$INSTALL_PATH" ] && { echo "❌ CasaOS安装文件未找到"; exit 1; }
          echo "✅ CasaOS安装完成，路径：$INSTALL_PATH"

      - name: 6-【恢复】快照强恢复（修复tar参数+权限+即时校验）
        if: ${{ env.WEBDAV_AVAILABLE == 'true' && env.HAS_SNAPSHOT == 'true' }}
        run: |
          set -e
          CASAOS_TMP_DIR="/tmp/casaos-recovery-tmp"
          # 修复：临时目录属主设为root，避免sudo写入后权限不匹配
          sudo mkdir -p "$CASAOS_TMP_DIR" && sudo chmod 700 "$CASAOS_TMP_DIR" && sudo chown root:root "$CASAOS_TMP_DIR"
          trap 'sudo rm -rf "$CASAOS_TMP_DIR" 2>/dev/null' EXIT
          
          # 停止服务
          sudo systemctl stop docker containerd casaos 2>/dev/null || true
          sudo pkill -9 docker containerd casaos 2>/dev/null || true
          sync && sleep 10
          
          # 空间校验
          TMP_FREE=$(df -P -B 1 /tmp | awk 'NR>1 {print $4}')
          TMP_FREE_GB=$(echo "$TMP_FREE / 1024 / 1024 / 1024" | bc -l)
          (( $(echo "$TMP_FREE_GB < 15" | bc -l) )) && { echo "❌ /tmp空间不足"; exit 1; }
          
          SNAP=${LATEST_SNAPSHOT}
          MD5=${LATEST_SNAPSHOT_MD5}
          RESTORE_OK=false
          
          # Rclone恢复（修复核心：tar参数顺序，取消错误屏蔽）
          if [ "${USE_RCLONE}" = true ]; then
            echo "ℹ️ 下载MD5文件"
            rclone copy mywebdav:${WEBDAV_SNAPSHOT_DIR}/${MD5} "$CASAOS_TMP_DIR" --config "${RCLONE_CONFIG}" --retries 5
            MD5_PATH="$CASAOS_TMP_DIR/${MD5}"
            [ ! -f "$MD5_PATH" ] || [ ! -s "$MD5_PATH" ] && { echo "❌ MD5文件无效"; exit 1; }
            
            # 核心修复：调整tar参数顺序（目录放最后），取消2>/dev/null暴露错误
            echo "ℹ️ 解压快照"
            if rclone cat mywebdav:${WEBDAV_SNAPSHOT_DIR}/${SNAP} --config "${RCLONE_CONFIG}" --retries 5 2>/dev/null | \
              tee >(md5sum -c "$MD5_PATH" >/dev/null 2>&1) | \
              sudo tar -I zstd -xf - -C / --overwrite --absolute-names --no-same-owner $PERSONAL_DATA_DIRS; then
              RESTORE_OK=true
              echo "✅ 快照恢复完成"
            else
              echo "❌ 解压/校验失败" && exit 1
            fi
          fi
          
          # 挂载模式恢复（同样修复tar参数）
          if [ "$RESTORE_OK" = false ] && [ "${USE_MOUNT}" = true ]; then
            REMOTE_DIR="${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}"
            [ ! -f "${REMOTE_DIR}/${SNAP}" ] || [ ! -f "${REMOTE_DIR}/${MD5}" ] && { echo "❌ 快照文件缺失"; exit 1; }
            md5sum -c "${REMOTE_DIR}/${MD5}" < "${REMOTE_DIR}/${SNAP}" 2>/dev/null || { echo "❌ MD5校验失败"; exit 1; }
            # 核心修复：调整tar参数顺序
            sudo tar -I zstd -xf "${REMOTE_DIR}/${SNAP}" -C / --overwrite --absolute-names --no-same-owner $PERSONAL_DATA_DIRS
            RESTORE_OK=true
          fi
          
          [ "$RESTORE_OK" = false ] && { echo "❌ 恢复失败"; exit 1; }
          
          # 新增：即时目录校验（确保恢复目录非空，提前发现问题）
          echo "ℹ️ 即时校验恢复目录有效性"
          REQUIRED_DIRS=(
            "/var/lib/docker"
            "/etc/casaos"
            "/var/lib/casaos"
          )
          for dir in "${REQUIRED_DIRS[@]}"; do
            if [ ! -d "$dir" ] || [ -z "$(ls -A "$dir" 2>/dev/null)" ]; then
              echo "❌ 恢复目录 $dir 为空或不存在，恢复失败" && exit 1
            fi
          done
          echo "✅ 恢复目录有效性校验通过"
          
          # 关键文件校验
          echo "ℹ️ 校验关键文件"
          REQUIRED_FILES=(
            "/var/lib/docker/version"
            "/etc/casaos/config.yaml"
            "/var/lib/casaos/db.sqlite"
          )
          for f in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$f" ] || [ ! -s "$f" ]; then
              echo "⚠️ 关键文件$f缺失/为空，尝试创建空文件继续"
              sudo touch "$f"
            fi
          done
          
          # 修复：权限校准（docker目录添加docker组，解决服务启动权限问题）
          sudo chown -R root:root $PERSONAL_DATA_DIRS
          sudo chgrp -R docker /var/lib/docker  # 关键：Docker数据目录添加docker组
          sudo chmod -R 755 /etc/casaos /DATA
          sudo chmod -R 700 /var/lib/casaos
          sudo chmod -R 700 /var/lib/docker
          echo "✅ 恢复+权限校准完成"

      - name: 7-【初始化】全新部署基础目录
        if: ${{ env.WEBDAV_AVAILABLE != 'true' || env.HAS_SNAPSHOT != 'true' }}
        run: |
          set -e
          sudo mkdir -p /etc/casaos /var/lib/casaos /DATA
          sudo chown -R root:root /etc/casaos /var/lib/casaos /DATA
          sudo chmod -R 755 /etc/casaos /DATA
          sudo chmod -R 700 /var/lib/casaos
          echo "✅ 基础目录创建完成"

      - name: 8-【服务】Docker+CasaOS启动校验
        run: |
          set -e
          # 启动Docker
          DOCKER_RETRY=5
          sudo systemctl restart docker containerd
          sleep 5
          while [ $DOCKER_RETRY -gt 0 ]; do
            if docker info >/dev/null 2>&1 && sudo systemctl is-active --quiet containerd; then
              break
            fi
            DOCKER_RETRY=$((DOCKER_RETRY-1))
            sudo systemctl restart docker containerd && sleep 15
          done
          [ $DOCKER_RETRY -eq 0 ] && { echo "❌ Docker启动失败"; exit 1; }
          
          # 启动CasaOS
          CASAOS_RETRY=5
          sudo systemctl enable --now casaos
          sleep 10
          while [ $CASAOS_RETRY -gt 0 ]; do
            if sudo lsof -i:80 | grep LISTEN >/dev/null 2>&1 && curl -fsSL --max-time 10 http://localhost >/dev/null 2>&1; then
              break
            fi
            CASAOS_RETRY=$((CASAOS_RETRY-1))
            sudo systemctl restart casaos && sleep 15
          done
          [ $CASAOS_RETRY -eq 0 ] && { echo "❌ CasaOS启动失败"; exit 1; }
          echo "✅ 所有服务启动成功"

      - name: 9-【组网】Tailscale配置（可选）
        if: ${{ env.TAILSCALE_AUTH_KEY != '' }}
        run: |
          set +e
          curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/noble.noarmor.gpg | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
          echo "deb [signed-by=/usr/share/keyrings/tailscale-archive-keyring.gpg] https://pkgs.tailscale.com/stable/ubuntu noble main" | sudo tee /etc/apt/sources.list.d/tailscale.list
          sudo apt update -y -qq && sudo apt install -y tailscale -qq
          
          sudo systemctl enable --now tailscaled
          sudo tailscale up --authkey="${TAILSCALE_AUTH_KEY}" --hostname="CasaOS-$(date +%Y%m%d)-$(hostname | cut -c1-6)" --accept-routes --accept-dns=false
          TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null || echo "组网失败")
          echo "TAILSCALE_IP=$TAILSCALE_IP" >> "$GITHUB_ENV"
          echo "✅ Tailscale IP：$TAILSCALE_IP"
          set -e

      - name: 10-【清理】系统垃圾+旧备份
        if: ${{ always() }}
        run: |
          set +e
          # 清理系统垃圾
          sudo rm -rf /usr/local/lib/* /opt/hostedtoolcache /tmp/* /var/tmp/* ~/.cache/* 2>/dev/null || true
          sudo apt autoremove --purge -y -qq && sudo apt clean -y -qq
          sudo journalctl --vacuum-size=100M --quiet
          
          # 清理旧备份
          if [ "${WEBDAV_AVAILABLE}" = true ]; then
            if [ "${USE_RCLONE}" = true ]; then
              BACKUPS=$(rclone ls mywebdav:${WEBDAV_SNAPSHOT_DIR} --config "${RCLONE_CONFIG}" --quiet | grep "casaos-full-snapshot.*\.tar\.zst" | sort -r | awk '{print $2}')
              COUNT=$(echo "$BACKUPS" | wc -l | tr -d ' ')
              if [ "$COUNT" -gt "$KEEP_BACKUPS" ]; then
                echo "$BACKUPS" | tail -n +$((KEEP_BACKUPS+1)) | while read f; do
                  [ -n "$f" ] && rclone delete mywebdav:${WEBDAV_SNAPSHOT_DIR}/$f --config "${RCLONE_CONFIG}" --quiet
                done
              fi
            fi
            if [ "${USE_MOUNT}" = true ]; then
              REMOTE_DIR="${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}"
              BACKUPS=$(ls -t "${REMOTE_DIR}"/casaos-full-snapshot*.tar.zst 2>/dev/null)
              COUNT=$(echo "$BACKUPS" | wc -l | tr -d ' ')
              if [ "$COUNT" -gt "$KEEP_BACKUPS" ]; then
                echo "$BACKUPS" | tail -n +$((KEEP_BACKUPS+1)) | xargs rm -f {} 2>/dev/null || true
              fi
            fi
          fi
          echo "✅ 清理完成"

      - name: 11-【校准】运行时长
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          set -e
          START=${WORKFLOW_START_TIMESTAMP}
          NOW=$(date +%s)
          DUR=$((NOW - START))
          TARGET=$((TARGET_RUN_MINUTES * 60))
          WAIT=$((TARGET - DUR))
          
          echo "📊 已运行：$((DUR/60))分$((DUR%60))秒"
          if [ $WAIT -gt 0 ]; then
            echo "⏳ 等待$((WAIT/60))分$((WAIT%60))秒"
            sleep $WAIT
          fi
          echo "✅ 时长校准完成"

      - name: 12-【备份】全量备份+自动续跑（修复tar参数+权限）
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          set -e
          CASAOS_BACKUP_TMP="/tmp/casaos-backup-tmp"
          # 修复：临时目录属主设为root，避免权限冲突
          sudo mkdir -p "$CASAOS_BACKUP_TMP" && sudo chmod 700 "$CASAOS_BACKUP_TMP" && sudo chown root:root "$CASAOS_BACKUP_TMP"
          trap 'sudo rm -rf "$CASAOS_BACKUP_TMP" 2>/dev/null' EXIT
          
          # 停止服务
          sudo systemctl stop docker containerd casaos 2>/dev/null || true
          sudo pkill -9 docker containerd casaos 2>/dev/null || true
          sync && sleep 10
          
          # 打包快照（核心修复：调整tar参数顺序）
          SNAP_NAME="casaos-full-snapshot-v1-$(date +%Y%m%d-%H%M%S).tar.zst"
          LOCAL_SNAP="$CASAOS_BACKUP_TMP/${SNAP_NAME}"
          LOCAL_MD5="$CASAOS_BACKUP_TMP/${SNAP_NAME}${SNAPSHOT_MD5_SUFFIX}"
          
          CPU_CORES=$(grep -c ^processor /proc/cpuinfo)
          ZSTD_THREADS=$(( CPU_CORES > 1 ? CPU_CORES - 1 : 1 ))
          # 核心修复：tar参数顺序（--absolute-names在前，排除规则+目录在后）
          sudo tar -I "zstd -T$ZSTD_THREADS ${ZSTD_LEVEL}" -cPf "$LOCAL_SNAP" --absolute-names $EXCLUDE_RULES $PERSONAL_DATA_DIRS
          [ ! -s "$LOCAL_SNAP" ] && { echo "❌ 快照打包失败"; exit 1; }
          
          # 生成MD5
          sudo md5sum "$LOCAL_SNAP" | sudo tee "$LOCAL_MD5" >/dev/null
          [ ! -s "$LOCAL_MD5" ] && { echo "❌ MD5生成失败"; exit 1; }
          
          # 修复：临时文件改属主为runner，让rclone可读取上传
          sudo chown runner:runner "$LOCAL_SNAP" "$LOCAL_MD5"
          # 上传备份
          BACKUP_OK=false
          if [ "${USE_RCLONE}" = true ]; then
            rclone copy "$LOCAL_SNAP" mywebdav:${WEBDAV_SNAPSHOT_DIR}/ --config "${RCLONE_CONFIG}" --transfers ${RCLONE_TRANSFERS} --retries ${RCLONE_RETRIES}
            rclone copy "$LOCAL_MD5" mywebdav:${WEBDAV_SNAPSHOT_DIR}/ --config "${RCLONE_CONFIG}"
            rclone ls mywebdav:${WEBDAV_SNAPSHOT_DIR}/${SNAP_NAME} --config "${RCLONE_CONFIG}" >/dev/null && BACKUP_OK=true
          elif [ "${USE_MOUNT}" = true ]; then
            sudo cp "$LOCAL_SNAP" "${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}/"
            sudo cp "$LOCAL_MD5" "${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}/"
            [ -f "${LOCAL_MOUNT_POINT}${WEBDAV_SNAPSHOT_DIR}/${SNAP_NAME}" ] && BACKUP_OK=true
          fi
          [ "$BACKUP_OK" = false ] && { echo "❌ 备份上传失败"; exit 1; }
          
          # 重启服务
          sudo systemctl enable --now docker containerd casaos && sleep 5
          
          # 自动续跑
          if [ -n "$USER_PAT" ] && [ -n "$REPO" ]; then
            RETRY=3
            RETRY_DELAY=10
            while [ $RETRY -gt 0 ]; do
              if curl -fsSL --fail -X POST -H "Authorization: token $USER_PAT" -H "Content-Type: application/json" https://api.github.com/repos/$REPO/dispatches -d '{"event_type":"renew_casaos_snapshot"}' --silent; then
                echo "✅ 续跑触发成功"
                break
              fi
              RETRY=$((RETRY-1))
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            done
            [ $RETRY -eq 0 ] && echo "⚠️ 续跑触发失败"
          else
            echo "⚠️ 续跑未配置"
          fi
          echo "✅ 备份+续跑流程完成"

      - name: 13-【收尾】敏感文件清理
        if: ${{ always() }}
        run: |
          set +e
          # 卸载挂载
          mount | grep -q "${LOCAL_MOUNT_POINT}" && sudo umount -l -f "${LOCAL_MOUNT_POINT}" --quiet 2>/dev/null || true
          
          # 清理敏感文件
          sudo rm -rf /tmp/* /var/tmp/* "${RCLONE_CONFIG}" /etc/davfs2/secrets ~/.rclone* "$GITHUB_WORKSPACE/casaos_install.log" 2>/dev/null || true
          
          echo "🎉 全流程完成，结束时间：$(date '+%Y-%m-%d %H:%M:%S')"
          set -e