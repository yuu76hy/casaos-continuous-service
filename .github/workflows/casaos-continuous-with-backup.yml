name: CasaOS-Tailscale-Full-Deploy

on:
  workflow_dispatch:  # æ‰‹åŠ¨è§¦å‘
  repository_dispatch:
    types: [renew_casaos_tailscale]  # ç»­è·‘è§¦å‘

jobs:
  deploy-casaos-tailscale:
    runs-on: ubuntu-24.04
    timeout-minutes: 360  # æœ€å¤§è¿è¡Œ6å°æ—¶
    permissions:
      contents: read
      actions: write  # å–æ¶ˆæ—§å·¥ä½œæµæƒé™
    env:
      # ========== æ ¸å¿ƒé…ç½®ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰ ==========
      MAX_RUN_MINUTES: 360
      SYNC_INTERVAL: 60
      WEBDAV_MOUNT_POINT: /home/runner/webdav_mount
      BACKUP_DIRS: "/z/Ubu"               # å›ºå®šå†™å…¥/z/Ubu
      CASAOS_DATA: /var/lib/casaos
      DOCKER_DATA: /var/lib/docker
      KEEP_BACKUP_COUNT: 2
      # ========== ç³»ç»Ÿæ’é™¤ç›®å½•ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰ ==========
      EXCLUDE_DIRS: >-
        /bin /boot /dev /lib /lib32 /lib64 /lost+found /proc /root /run /sbin /sys /tmp
        /var/cache /var/log /var/tmp /var/backups /home/runner /mnt /media
        /usr/share/doc /usr/share/man /usr/share/locale /etc/ssl/certs
        /etc/fstab /etc/mtab /etc/hostname /etc/machine-id
      # ========== WebDAVæŒ‚è½½é‡è¯•é…ç½®ï¼ˆé€‚é…Cloud Runï¼‰ ==========
      MOUNT_RETRY_COUNT: 5
      MOUNT_RETRY_DELAY: 10  # å»¶é•¿é‡è¯•é—´éš”åˆ°10ç§’ï¼Œé€‚é…Cloud Runå†·å¯åŠ¨
      # ========== GitHubè‡ªåŠ¨æ³¨å…¥å˜é‡ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰ ==========
      REPO: ${{ github.repository }}
      CURRENT_RUN_ID: ${{ github.run_id }}
      WORKFLOW_NAME: ${{ github.workflow }}

    steps:
      # ========== æ­¥éª¤1ï¼šç³»ç»Ÿåˆå§‹åŒ– + ä¾èµ–å®‰è£… ==========
      - name: Step 1 - System Init & Dependency Install
        run: |
          echo "===== ç³»ç»Ÿç¯å¢ƒåˆå§‹åŒ– ====="
          # æ›´æ–°ç³»ç»Ÿå¹¶å®‰è£…åŸºç¡€ä¾èµ–
          sudo apt update -y && sudo apt install -y rsync curl wget jq fuse3 openssl || { echo "âŒ ä¾èµ–å®‰è£…å¤±è´¥"; exit 1; }
          # å®‰è£…rcloneï¼ˆé€‚é…Cloud Runçš„æœ€æ–°ç‰ˆæœ¬ï¼‰
          curl -fsSL https://rclone.org/install.sh | sudo bash
          # é…ç½®fuseå…è®¸érootç”¨æˆ·æŒ‚è½½
          echo "user_allow_other" | sudo tee -a /etc/fuse.conf
          # é…ç½®runnerå…å¯†sudo
          echo "runner ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/runner
          sudo chmod 0440 /etc/sudoers.d/runner
          # ä¼˜åŒ–Dockeré…ç½®ï¼ˆé™åˆ¶æ—¥å¿—å¤§å°ï¼‰
          sudo mkdir -p /etc/systemd/system/docker.service.d
          echo '[Service]
          ExecStart=
          ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --log-opt max-size=10m --log-opt max-file=2' | sudo tee /etc/systemd/system/docker.service.d/override.conf
          sudo systemctl daemon-reload
          # åˆå§‹åƒåœ¾æ¸…ç†
          sudo rm -rf /tmp/* /var/tmp/*
          sudo apt clean && sudo apt autoclean && sudo apt autoremove -y
          sudo journalctl --vacuum-time=1d
          sudo find /var/log -type f -mtime +1 -delete
          echo "âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ"

      # ========== æ­¥éª¤2ï¼šåˆ›å»ºè°ƒè¯•ç”¨æˆ·ï¼ˆå®‰å…¨éšæœºå¯†ç ï¼‰ ==========
      - name: Step 2 - Create Debug User
        run: |
          echo "===== åˆ›å»ºè°ƒè¯•ç”¨æˆ· ====="
          # åˆ›å»ºå¸¦sudoæƒé™çš„è°ƒè¯•ç”¨æˆ·
          sudo useradd -m -s /bin/bash roots
          ROOT_PASSWORD=$(openssl rand -base64 12)
          echo "roots:$ROOT_PASSWORD" | sudo chpasswd
          sudo usermod -aG sudo roots
          # å¯†ç å®‰å…¨å­˜å‚¨ï¼ˆä¸è¾“å‡ºåˆ°æ—¥å¿—ï¼‰
          echo "$ROOT_PASSWORD" | sudo tee /root/debug_password.txt > /dev/null
          sudo chmod 600 /root/debug_password.txt
          echo "âœ… è°ƒè¯•ç”¨æˆ·åˆ›å»ºå®Œæˆ | è´¦å·ï¼šroots | å¯†ç å·²ä¿å­˜è‡³ /root/debug_password.txt"

      # ========== æ­¥éª¤3ï¼šWebDAVæŒ‚è½½ï¼ˆé€‚é…Cloud Runï¼ŒæŒ‡å®š/z/Ubuå†™å…¥ï¼‰ ==========
      - name: Step 3 - Mount WebDAV (Cloud Runé€‚é… + /z/Ubuå†™å…¥)
        env:
          WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
          WEBDAV_USER: ${{ secrets.WEBDAV_USER }}
          WEBDAV_PASSWORD: ${{ secrets.WEBDAV_PASSWORD }}
        run: |
          echo "===== æŒ‚è½½ WebDAV å­˜å‚¨ï¼ˆæŒ‡å®š/z/Ubuå†™å…¥ï¼Œé€‚é…Cloud Runï¼‰ ====="
          # éªŒè¯URLæ ¼å¼ï¼ˆé€‚é…Cloud RunåŸŸåï¼‰
          if [[ ! "$WEBDAV_URL" =~ ^https://.*\.ap-northeast-1\.clawcloudrun\.com/$ ]]; then
            echo "âš ï¸ æ£€æµ‹åˆ°éæ ‡å‡†Cloud Run URLæ ¼å¼ï¼Œå½“å‰URL: $WEBDAV_URL"
            echo "å»ºè®®æ ¼å¼ï¼šhttps://xxx.ap-northeast-1.clawcloudrun.com/"
          fi

          # ç¡®ä¿URLæœ«å°¾å¸¦/ï¼ˆå…¼å®¹ç”¨æˆ·è¾“å…¥ï¼‰
          WEBDAV_URL_FIXED="${WEBDAV_URL%/}/"
          echo "ğŸ”§ æœ€ç»ˆä½¿ç”¨çš„WebDAV URL: $WEBDAV_URL_FIXED"

          # åˆ›å»ºæœ¬åœ°æŒ‚è½½ç‚¹
          mkdir -p "$WEBDAV_MOUNT_POINT"
          
          # é…ç½®rcloneï¼ˆé€‚é…Cloud Run HTTPS + åŸºæœ¬è®¤è¯ï¼‰
          rclone config create mywebdav webdav \
            url="$WEBDAV_URL_FIXED" \
            vendor="other" \
            user="$WEBDAV_USER" \
            pass="$WEBDAV_PASSWORD" \
            --obscure \
            --config /home/runner/.rclone.conf

          # æ‰“å°è„±æ•é…ç½®ï¼ˆæ’æŸ¥ç”¨ï¼‰
          echo "ğŸ“ rcloneé…ç½®æ‘˜è¦ï¼ˆè„±æ•ï¼‰ï¼š"
          rclone config show mywebdav --config /home/runner/.rclone.conf | sed 's/pass = .*/pass = *** ENCRYPTED ***/'

          # æµ‹è¯•Cloud Run WebDAVè¿æ¥ï¼ˆä¼˜åŒ–è¶…æ—¶/é‡è¯•ï¼Œé€‚é…å†·å¯åŠ¨ï¼‰
          echo "ğŸ” æµ‹è¯•Cloud Run WebDAVè¿æ¥ï¼ˆå…è®¸å†·å¯åŠ¨å»¶è¿Ÿï¼‰..."
          if ! rclone ls mywebdav: --config /home/runner/.rclone.conf \
            --log-level DEBUG \
            --timeout 30s \     # å»¶é•¿è¶…æ—¶åˆ°30ç§’ï¼Œé€‚é…Cloud Runå†·å¯åŠ¨
            --retries 3 \       # å¢åŠ é‡è¯•æ¬¡æ•°
            --low-level-retries 10 \
            2>/tmp/rclone_test.log; then
            
            echo "âŒ Cloud Run WebDAVè¿æ¥å¤±è´¥"
            echo "ğŸ“š è¯¦ç»†é”™è¯¯æ—¥å¿—ï¼ˆè„±æ•ï¼‰ï¼š"
            cat /tmp/rclone_test.log | sed 's/Authorization: .*/Authorization: *** REDACTED ***/'
            echo "ğŸ’¡ æ’æŸ¥å»ºè®®ï¼š"
            echo "  1. ç¡®è®¤Cloud RunæœåŠ¡å·²å¯åŠ¨ï¼ˆæ— æœåŠ¡å™¨æœåŠ¡å¯èƒ½å†·å¯åŠ¨ï¼‰"
            echo "  2. æ£€æŸ¥WEBDAV_USER/WEBDAV_PASSWORDæ˜¯å¦æ­£ç¡®"
            echo "  3. ç¡®è®¤Cloud Runå®‰å…¨ç»„å…è®¸443ç«¯å£è®¿é—®"
            exit 1
          fi

          # åå°æŒ‚è½½WebDAVï¼ˆä¼˜åŒ–Cloud Runé€‚é…å‚æ•°ï¼‰
          nohup rclone mount mywebdav: "$WEBDAV_MOUNT_POINT" \
            --config /home/runner/.rclone.conf \
            --vfs-cache-mode full \          # å…¨ç¼“å­˜æ¨¡å¼ï¼Œè§£å†³å†™å…¥404
            --vfs-cache-max-age 24h \
            --vfs-cache-max-size 10G \
            --buffer-size 64M \
            --daemon-timeout 10m \           # å»¶é•¿å®ˆæŠ¤è¿›ç¨‹è¶…æ—¶
            --allow-other \
            --allow-non-empty \
            --umask 022 \
            --log-file /tmp/rclone.log \
            --log-level INFO \
            --timeout 30s \                  # å»¶é•¿ç½‘ç»œè¶…æ—¶
            --retries 3 \                    # å¢åŠ é‡è¯•æ¬¡æ•°
            --low-level-retries 10 \         # åº•å±‚è¿æ¥é‡è¯•
            >/dev/null 2>&1 &
          
          # æŒ‚è½½éªŒè¯ï¼ˆå»¶é•¿ç­‰å¾…ï¼Œé€‚é…Cloud Runå†·å¯åŠ¨ï¼‰
          sleep 20  # æ¯”é»˜è®¤å¤šç­‰5ç§’ï¼Œç¡®ä¿æœåŠ¡å°±ç»ª
          MOUNT_SUCCESS=false
          WRITE_TEST_SUCCESS=false
          
          for i in $(seq 1 $MOUNT_RETRY_COUNT); do
            echo "ğŸ” æ£€æŸ¥ WebDAV æŒ‚è½½çŠ¶æ€ (å°è¯• $i/$MOUNT_RETRY_COUNT)..."
            
            if timeout 15 ls "$WEBDAV_MOUNT_POINT" >/dev/null 2>&1; then  # å»¶é•¿lsè¶…æ—¶
              echo "âœ… ç›®å½•å¯è¯»ï¼ŒéªŒè¯/z/Ubuå†™å…¥æƒé™ï¼ˆCloud Runï¼‰..."
              
              # æ˜¾å¼åˆ›å»º/z/Ubu/testç›®å½•å¹¶æµ‹è¯•å†™å…¥
              TEST_DIR="$WEBDAV_MOUNT_POINT/z/Ubu/test"
              mkdir -p "$TEST_DIR"
              test_file="$TEST_DIR/mount_test_$(date -u +%s)_cloudrun.txt"
              echo "mount_test_$(date -u +%s)_cloudrun" > "$test_file"
              
              # éªŒè¯æ–‡ä»¶å†™å…¥æˆåŠŸ
              if [ -f "$test_file" ]; then
                # è¿œç¨‹éªŒè¯ï¼ˆå»¶é•¿è¶…æ—¶ï¼Œé€‚é…è·¨åŒºåŸŸå»¶è¿Ÿï¼‰
                if rclone ls mywebdav:z/Ubu/test/ --config /home/runner/.rclone.conf \
                  --timeout 20s \
                  | grep -q "$(basename $test_file)"; then
                  
                  # æ¸…ç†æµ‹è¯•æ–‡ä»¶
                  rm -rf "$WEBDAV_MOUNT_POINT/z/Ubu/test"
                  rclone delete mywebdav:z/Ubu/test/ --config /home/runner/.rclone.conf \
                    --timeout 20s >/dev/null 2>&1
                  
                  MOUNT_SUCCESS=true
                  WRITE_TEST_SUCCESS=true
                  echo "âœ… /z/Ubu ç›®å½•å†™å…¥éªŒè¯é€šè¿‡ï¼ˆCloud Runé€‚é…æˆåŠŸï¼‰"
                  break
                fi
              fi
              
              # æ¸…ç†æµ‹è¯•ç›®å½•ï¼ˆé‡è¯•æ—¶ï¼‰
              rm -rf "$WEBDAV_MOUNT_POINT/z/Ubu/test"
            fi
            
            echo "âš ï¸ /z/Ubu å†™å…¥éªŒè¯å¤±è´¥ï¼Œç­‰å¾… $MOUNT_RETRY_DELAY ç§’åé‡è¯•ï¼ˆCloud Runï¼‰"
            sleep $MOUNT_RETRY_DELAY
          done
          
          if [ "$WRITE_TEST_SUCCESS" = "false" ]; then
            echo "âŒ /z/Ubu ç›®å½•å†™å…¥éªŒè¯å¤±è´¥ï¼ˆCloud Runï¼‰"
            echo "ğŸ“Š æŒ‚è½½æ—¥å¿—ï¼ˆè„±æ•ï¼‰:"
            cat /tmp/rclone.log 2>/dev/null | sed 's/Authorization: .*/Authorization: *** REDACTED ***/' || echo "æ— æ—¥å¿—æ–‡ä»¶"
            echo "WEBDAV_AVAILABLE=false" >> "$GITHUB_ENV"
            exit 0
          fi
          
          echo "WEBDAV_AVAILABLE=true" >> "$GITHUB_ENV"
          
          # åˆå§‹åŒ–/z/Ubuå¤‡ä»½ç›®å½•
          target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
          mkdir -p "${target_path}/tmp_incremental" "${target_path}/sync_logs"
          if [ -n "$(ls -A "${target_path}" 2>/dev/null)" ]; then
            echo "âœ… æ£€æµ‹åˆ°/z/Ubuå·²æœ‰å¤‡ä»½æ•°æ®ï¼ˆCloud Runï¼‰"
            echo "HAS_z_Ubu=true" >> "$GITHUB_ENV"
          else
            echo "âš ï¸ åˆå§‹åŒ–/z/Ubuå¤‡ä»½ç›®å½•ï¼ˆCloud Runï¼‰"
            echo "HAS_z_Ubu=false" >> "$GITHUB_ENV"
          fi

      # ========== æ­¥éª¤4ï¼šæ™ºèƒ½æ•°æ®æ¢å¤ï¼ˆä»/z/Ubuæ¢å¤ï¼‰ ==========
      - name: Step 4 - Smart Data Restore (ä»/z/Ubuæ¢å¤)
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          echo "===== ä»/z/Ubuæ¢å¤æ•°æ®ï¼ˆCloud Runï¼‰ ====="
          RESTORE_DONE=false
          
          # ä»…æ¢å¤å…³é”®æ•°æ®ç›®å½•
          RESTORE_DIRS=(
            "/var/lib/casaos"
            "/var/lib/docker/volumes"
            "/opt/casaos"
          )
          
          target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
          if [ "${HAS_z_Ubu}" = "true" ]; then
            latest_full_backup=$(ls -dt "${target_path}"/[0-9]* 2>/dev/null | head -n 1)
            incremental_dir="${target_path}/tmp_incremental"
            
            # æ¢å¤ä¼˜å…ˆçº§ï¼šå…¨é‡å¤‡ä»½ > å¢é‡ç›®å½•
            if [ -n "$latest_full_backup" ] && [ -d "$latest_full_backup" ]; then
              echo "ğŸ”„ ä»/z/Ubuå…¨é‡å¤‡ä»½æ¢å¤ï¼š$latest_full_backup"
              restore_source="${latest_full_backup}/"
            elif [ -n "$(ls -A "${incremental_dir}" 2>/dev/null)" ]; then
              echo "ğŸ”„ ä»/z/Ubuå¢é‡ç›®å½•æ¢å¤ï¼š$incremental_dir"
              restore_source="${incremental_dir}/"
            else
              echo "âš ï¸ /z/Ubuæ— æœ‰æ•ˆå¤‡ä»½ï¼Œè·³è¿‡æ¢å¤"
              RESTORE_DONE=false
            fi
            
            if [ -n "$restore_source" ]; then
              for restore_dir in "${RESTORE_DIRS[@]}"; do
                if [ -d "${restore_source}${restore_dir#/}" ]; then
                  echo "ğŸ”„ æ¢å¤ç›®å½•: $restore_dir"
                  sudo mkdir -p "$(dirname "${restore_dir}")"
                  
                  # æ„å»ºæ’é™¤å‚æ•°
                  EXCLUDE_PARAMS=()
                  for excl in $EXCLUDE_DIRS; do
                    EXCLUDE_PARAMS+=("--exclude=${excl}")
                  done
                  
                  # æ‰§è¡Œæ¢å¤
                  sudo rsync -av --copy-links --sparse --numeric-ids \
                    "${EXCLUDE_PARAMS[@]}" \
                    "${restore_source}${restore_dir#/}/" "${restore_dir}/"
                fi
              done
              
              echo "âœ… /z/Ubuæ•°æ®æ¢å¤å®Œæˆï¼ˆCloud Runï¼‰"
              RESTORE_DONE=true
            fi
          fi
          
          echo "DATA_RESTORED=${RESTORE_DONE}" >> "$GITHUB_ENV"

      # ========== æ­¥éª¤5ï¼šå®‰è£…/è·³è¿‡ CasaOS ==========
      - name: Step 5 - Install or Skip CasaOS
        run: |
          echo "===== éƒ¨ç½² CasaOS æœåŠ¡ ====="
          if [ -d "${CASAOS_DATA}" ] && [ "${DATA_RESTORED}" = "true" ]; then
            echo "âœ… æ£€æµ‹åˆ°æ¢å¤æ•°æ®ï¼Œè·³è¿‡å®‰è£…"
          else
            # å®‰è£…CasaOSï¼ˆå®˜æ–¹è„šæœ¬ï¼‰
            curl -fsSL https://get.casaos.io | sudo bash || { echo "âŒ CasaOS å®‰è£…å¤±è´¥"; exit 1; }
            echo "âœ… CasaOS å®‰è£…å®Œæˆ"
          fi

      # ========== æ­¥éª¤6ï¼šå¯åŠ¨æ ¸å¿ƒæœåŠ¡ï¼ˆå¸¦é‡è¯•ï¼‰ ==========
      - name: Step 6 - Start Docker & CasaOS with Retry
        run: |
          echo "===== å¯åŠ¨æ ¸å¿ƒæœåŠ¡ ====="
          sudo systemctl enable --now docker casaos
          
          # æœåŠ¡å¯åŠ¨é‡è¯•æœºåˆ¶
          max_retries=10
          retry_count=0
          services=("docker" "casaos")
          
          while [ $retry_count -lt $max_retries ]; do
            all_active=true
            
            for service in "${services[@]}"; do
              if ! sudo systemctl is-active --quiet "$service"; then
                echo "ğŸ”„ æœåŠ¡ $service æœªå°±ç»ªï¼Œé‡è¯•ä¸­... ($retry_count/$max_retries)"
                all_active=false
                break
              fi
            done
            
            if [ "$all_active" = "true" ]; then
              echo "âœ… æ‰€æœ‰æœåŠ¡å·²æˆåŠŸå¯åŠ¨"
              break
            fi
            
            ((retry_count++))
            sleep 5
          done
          
          if [ "$all_active" = "false" ]; then
            echo "âŒ æœåŠ¡å¯åŠ¨è¶…æ—¶"
            for service in "${services[@]}"; do
              echo "ğŸ“Š $service çŠ¶æ€:"
              sudo systemctl status "$service" --no-pager
            done
            exit 1
          fi
          
          # ç­‰å¾…CasaOS APIå°±ç»ª
          echo "â³ ç­‰å¾… CasaOS API å°±ç»ª..."
          timeout=60
          start_time=$(date +%s)
          
          while true; do
            if curl -m 5 -s http://localhost:80/api/v1/sys/version >/dev/null 2>&1; then
              echo "âœ… CasaOS API å·²å°±ç»ª"
              break
            fi
            
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ CasaOS API å¯åŠ¨è¶…æ—¶"
              exit 1
            fi
            
            sleep 2
            echo -n "."
          done

      # ========== æ­¥éª¤7ï¼šTailscaleé…ç½®ï¼ˆä»…IPv4ï¼Œé€‚é…Cloud Runï¼‰ ==========
      - name: Step 7 - Deploy Tailscale (Only IPv4 + Cloud Runé€‚é…)
        env:
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          echo "===== é…ç½® Tailscale å†…ç½‘ç©¿é€ï¼ˆä»…IPv4ï¼‰ ====="
          if [ -z "$TAILSCALE_AUTH_KEY" ]; then
            echo "âš ï¸ æœªé…ç½® TAILSCALE_AUTH_KEYï¼Œè·³è¿‡ç»„ç½‘"
            echo "TAILSCALE_IP=" >> "$GITHUB_ENV"
            exit 0
          fi
          
          # å®‰è£…Tailscale
          curl -fsSL https://tailscale.com/install.sh | sudo bash
          
          # è®¾ç½®ä¸»æœºåï¼ˆåŒ…å«Cloud Runæ ‡è¯†ï¼‰
          HOSTNAME="casaos-${GITHUB_RUN_ID:0:12}-cloudrun"
          # å¼ºåˆ¶ä»…ä½¿ç”¨IPv4ï¼Œé€‚é…Cloud Runç½‘ç»œ
          sudo tailscale up --authkey="$TAILSCALE_AUTH_KEY" \
            --accept-routes \
            --accept-dns \
            --hostname="$HOSTNAME" \
            --advertise-routes=0.0.0.0/0 \  # ä»…IPv4è·¯ç”±
            --force-ipv4=true \              # å¼ºåˆ¶IPv4
            --timeout=30s                    # å»¶é•¿è¶…æ—¶
            
          # è·å–Tailscale IPv4åœ°å€ï¼ˆå¸¦é‡è¯•ï¼‰
          max_retries=5
          retry_count=0
          TAILSCALE_IP=""
          
          while [ $retry_count -lt $max_retries ]; do
            TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null | head -n1)
            if [ -n "$TAILSCALE_IP" ]; then
              echo "âœ… Tailscale IPv4 åœ°å€ï¼š$TAILSCALE_IP"
              echo "TAILSCALE_IP=${TAILSCALE_IP}" >> "$GITHUB_ENV"
              break
            fi
            
            echo "â³ ç­‰å¾… Tailscale è·å– IPv4 åœ°å€... ($retry_count/$max_retries)"
            ((retry_count++))
            sleep 5
          done
          
          if [ -z "$TAILSCALE_IP" ]; then
            echo "âŒ Tailscale ç»„ç½‘å¤±è´¥ï¼Œæœªè·å–åˆ°IPv4åœ°å€"
            echo "ğŸ“Š Tailscale çŠ¶æ€:"
            sudo tailscale status --json
            echo "TAILSCALE_IP=" >> "$GITHUB_ENV"
          fi

      # ========== æ­¥éª¤8ï¼šè¾“å‡ºè®¿é—®ä¿¡æ¯ ==========
      - name: Step 8 - Print Access Info
        run: |
          echo "===== æœåŠ¡è®¿é—®ä¿¡æ¯ ====="
          PUBLIC_IP=$(curl -s --max-time 10 ifconfig.me || echo "è·å–å¤±è´¥")
          
          echo "ğŸ”— å…¬ç½‘ IPv4 è®¿é—®ï¼šhttp://$PUBLIC_IP"
          
          if [ -n "$TAILSCALE_IP" ]; then
            echo "ğŸ”’ Tailscale IPv4 è®¿é—®ï¼šhttp://$TAILSCALE_IP"
            echo "ğŸŒ Tailscale çŠ¶æ€é¡µï¼šhttps://login.tailscale.com/admin/machines/$TAILSCALE_IP"
          fi
          
          echo "ğŸ‘¤ è°ƒè¯•ç”¨æˆ·ï¼šrootsï¼ˆå¯†ç ä½äº /root/debug_password.txtï¼‰"
          echo "âš ï¸ å®‰å…¨æç¤ºï¼šç«‹å³ä¿®æ”¹rootså¯†ç ï¼Œä¸è¦æš´éœ²å…¬ç½‘IP"

      # ========== æ­¥éª¤9ï¼šä¿æ´»+åŒæ­¥+å¤‡ä»½+ç»­è·‘ï¼ˆé€‚é…Cloud Runï¼‰ ==========
      - name: Step 9 - Keep Alive + Sync + Backup + Renew (Cloud Runé€‚é…)
        env:
          USER_PAT: ${{ secrets.USER_PAT }}
        shell: bash
        run: |
          echo "===== è¿›å…¥ä¿æ´»å¾ªç¯ï¼ˆæ•°æ®åŒæ­¥è‡³/z/Ubuï¼Œé€‚é…Cloud Runï¼‰ ====="
          start_time=$(date +%s)
          last_sync_minute=-$SYNC_INTERVAL
          health_check_interval=60

          # å‡½æ•°1ï¼šè§¦å‘ç»­è·‘
          trigger_renew() {
            echo "===== è§¦å‘ç»­è·‘å·¥ä½œæµ ====="
            if [ -z "$USER_PAT" ] || [ -z "$REPO" ]; then
              echo "âŒ ç¼ºå°‘USER_PATï¼Œæ— æ³•ç»­è·‘"
              return 1
            fi
            
            payload=$(cat <<EOF
            {
              "event_type": "renew_casaos_tailscale",
              "client_payload": {
                "previous_run_id": "$CURRENT_RUN_ID",
                "workflow_name": "$WORKFLOW_NAME"
              }
            }
            EOF
            )
            
            response=$(curl -fsS -w "HTTP_STATUS:%{http_code}" \
              -X POST \
              -H "Authorization: token $USER_PAT" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              "https://api.github.com/repos/$REPO/dispatches" \
              -d "$payload" 2>&1)
            
            http_status=$(echo "$response" | grep -oP 'HTTP_STATUS:\K\d+')
            
            if [ "$http_status" = "204" ]; then
              echo "âœ… ç»­è·‘è§¦å‘æˆåŠŸ"
              exit 0
            else
              echo "âŒ ç»­è·‘è§¦å‘å¤±è´¥ (HTTP $http_status)"
              return 1
            fi
          }

          # å‡½æ•°2ï¼šDockeråƒåœ¾æ¸…ç†
          clean_docker_garbage() {
            echo "===== Docker åƒåœ¾æ¸…ç† ====="
            sudo docker stop $(sudo docker ps -aq -f status=exited 2>/dev/null) 2>/dev/null || true
            sudo docker rm $(sudo docker ps -aq -f status=exited 2>/dev/null) 2>/dev/null || true
            sudo docker system prune -af --filter "until=24h" >/dev/null 2>&1 || true
            sudo docker volume prune -f --filter "until=24h" >/dev/null 2>&1 || true
          }

          # å‡½æ•°3ï¼šæ¸…ç†/z/Ubuæ—§å¤‡ä»½ï¼ˆCloud Runé€‚é…ï¼‰
          clean_old_backups() {
            if [ "${WEBDAV_AVAILABLE:-false}" != "true" ]; then return 1; fi
            echo "===== æ¸…ç†/z/Ubuæ—§å¤‡ä»½ï¼ˆCloud Runï¼‰ ====="
            target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
            backup_folders=$(find "${target_path}" -maxdepth 1 -type d -name '[0-9]*' 2>/dev/null | sort -r)
            total_backups=$(echo "$backup_folders" | wc -l)
            to_delete=$((total_backups - KEEP_BACKUP_COUNT))
            
            if [ $to_delete -gt 0 ]; then
              count=0
              while IFS= read -r folder; do
                if [ $count -ge $to_delete ]; then break; fi
                echo "ğŸ—‘ï¸ åˆ é™¤/z/Ubuæ—§å¤‡ä»½: $(basename "${folder}")"
                sudo rm -rf "$folder"
                ((count++))
              done <<< "$backup_folders"
            fi
          }

          # å‡½æ•°4ï¼šå¢é‡åŒæ­¥è‡³/z/Ubuï¼ˆCloud Runé€‚é…ï¼‰
          incremental_sync() {
            if [ "${WEBDAV_AVAILABLE:-false}" != "true" ]; then return 1; fi
            echo "===== å¢é‡åŒæ­¥è‡³/z/Ubuï¼ˆCloud Runï¼‰ ====="
            SYNC_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            
            target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
            sync_dir="${target_path}/tmp_incremental"
            log_file="${target_path}/sync_logs/sync_$(date -u +%Y%m%d_%H%M%S)_cloudrun.log"
            mkdir -p "$(dirname "${log_file}")"
            
            # ä»…åŒæ­¥å…³é”®ç›®å½•
            SYNC_DIRS=(
              "/var/lib/casaos"
              "/var/lib/docker/volumes"
              "/opt/casaos"
              "/etc/casaos"
            )
            
            # æ„å»ºæ’é™¤å‚æ•°ï¼ˆæ’é™¤æŒ‚è½½ç‚¹å’Œç³»ç»Ÿç›®å½•ï¼‰
            EXCLUDE_PARAMS=("--exclude=${WEBDAV_MOUNT_POINT}")
            for excl in $EXCLUDE_DIRS; do
              EXCLUDE_PARAMS+=("--exclude=${excl}")
            done
            
            sync_success=true
            for sync_dir_entry in "${SYNC_DIRS[@]}"; do
              if [ -d "$sync_dir_entry" ]; then
                echo "ğŸ”„ åŒæ­¥: $sync_dir_entry" >> "$log_file"
                # å¢é‡åŒæ­¥ï¼ˆé€‚é…Cloud Runç½‘ç»œå»¶è¿Ÿï¼‰
                sudo rsync -av --update --compress --copy-links --sparse --numeric-ids \
                  --timeout 30s \
                  "${EXCLUDE_PARAMS[@]}" \
                  "${sync_dir_entry}/" "${sync_dir}/${sync_dir_entry#/}/" >> "$log_file" 2>&1
                  
                if [ $? -ne 0 ]; then
                  sync_success=false
                fi
              fi
            done
            
            if $sync_success; then
              echo "incremental_sync_time=${SYNC_TIME}" > "${sync_dir}/sync_info_cloudrun.txt"
              echo "âœ… /z/Ubuå¢é‡åŒæ­¥å®Œæˆï¼ˆCloud Runï¼‰"
              return 0
            else
              echo "âŒ /z/Ubuå¢é‡åŒæ­¥å¤±è´¥ï¼ˆCloud Runï¼‰"
              return 1
            fi
          }

          # å‡½æ•°5ï¼šå…¨é‡å¤‡ä»½è‡³/z/Ubuï¼ˆCloud Runé€‚é…ï¼‰
          full_backup() {
            if [ "${WEBDAV_AVAILABLE:-false}" != "true" ]; then return 1; fi
            clean_docker_garbage
            echo "===== å…¨é‡å¤‡ä»½è‡³/z/Ubuï¼ˆCloud Runï¼‰ ====="
            BACKUP_SUCCESS=false
            
            target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
            full_backup_dir="${target_path}/$(date -u +%Y%m%d_%H%M%S)_cloudrun"
            incremental_dir="${target_path}/tmp_incremental"
            mkdir -p "$full_backup_dir"
            
            # æ•°æ®æºï¼šå¢é‡ç›®å½• > ç³»ç»Ÿç›®å½•
            if [ -n "$(ls -A "${incremental_dir}" 2>/dev/null)" ]; then
              backup_source="${incremental_dir}/"
            else
              backup_source="/"
            fi
            
            # ä»…å¤‡ä»½å…³é”®ç›®å½•
            BACKUP_DIRS=(
              "/var/lib/casaos"
              "/var/lib/docker/volumes"
              "/opt/casaos"
              "/etc/casaos"
            )
            
            # æ„å»ºæ’é™¤å‚æ•°
            EXCLUDE_PARAMS=("--exclude=${WEBDAV_MOUNT_POINT}")
            for excl in $EXCLUDE_DIRS; do
              EXCLUDE_PARAMS+=("--exclude=${excl}")
            done
            
            backup_success=true
            for backup_dir in "${BACKUP_DIRS[@]}"; do
              source_path="${backup_source}${backup_dir#/}"
              if [ -d "$source_path" ]; then
                echo "ğŸ“¦ å¤‡ä»½: $backup_dir"
                mkdir -p "${full_backup_dir}${backup_dir}"
                # å…¨é‡å¤‡ä»½ï¼ˆé€‚é…Cloud Runç½‘ç»œï¼‰
                sudo rsync -av --copy-links --sparse --numeric-ids \
                  --timeout 30s \
                  "${EXCLUDE_PARAMS[@]}" \
                  "${source_path}/" "${full_backup_dir}${backup_dir}/" >/dev/null 2>&1
                  
                if [ $? -ne 0 ]; then
                  backup_success=false
                fi
              fi
            done
            
            if $backup_success; then
              # å†™å…¥å¤‡ä»½ä¿¡æ¯ï¼ˆåŒ…å«Cloud Runæ ‡è¯†ï¼‰
              printf "backup_time=%s\nrunner_id=%s\ntype=full_backup\nplatform=cloudrun\n" \
                "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
                "$CURRENT_RUN_ID" > "${full_backup_dir}/backup_info.txt"
              echo "âœ… /z/Ubuå…¨é‡å¤‡ä»½å®Œæˆï¼ˆCloud Runï¼‰ï¼š$full_backup_dir"
              clean_old_backups
              BACKUP_SUCCESS=true
            else
              sudo rm -rf "$full_backup_dir"
            fi
            
            $BACKUP_SUCCESS
          }

          # å‡½æ•°6ï¼šæœåŠ¡å¥åº·æ£€æŸ¥ï¼ˆé€‚é…Cloud Runï¼‰
          check_service_health() {
            local service_name=$1
            local url=$2
            local port=$3
            
            # æ£€æŸ¥ç«¯å£ç›‘å¬
            if [ -n "$port" ] && ! sudo lsof -i :"$port" >/dev/null 2>&1; then
              echo "âŒ $service_name ç«¯å£ $port æœªç›‘å¬"
              return 1
            fi
            
            # æ£€æŸ¥HTTPå¯ç”¨æ€§ï¼ˆå»¶é•¿è¶…æ—¶ï¼‰
            if [ -n "$url" ] && ! curl -m 10 -s "$url" >/dev/null 2>&1; then
              echo "âŒ $service_name HTTP ä¸å¯ç”¨ï¼ˆCloud Runç½‘ç»œå»¶è¿Ÿï¼‰"
              return 1
            fi
            
            echo "âœ… $service_name å¥åº·ï¼ˆCloud Runï¼‰"
            return 0
          }

          # åˆå§‹åŒ–ï¼šå–æ¶ˆæ—§å·¥ä½œæµå®ä¾‹
          if [ -n "$USER_PAT" ]; then
            echo "===== å–æ¶ˆæ—§å·¥ä½œæµå®ä¾‹ ====="
            response=$(curl -fsS \
              -H "Authorization: token $USER_PAT" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/actions/runs?status=in_progress&per_page=100")
            
            old_runs=$(echo "$response" | jq -r --arg WF_NAME "$WORKFLOW_NAME" --arg CURRENT_ID "$CURRENT_ID" \
              '.workflow_runs[] | select(.name == $WF_NAME and .id != ($CURRENT_ID | tonumber)) | .id')
            
            if [ -n "$old_runs" ] && [ "$old_runs" != "null" ]; then
              while IFS= read -r RUN_ID; do
                if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
                  echo "ğŸ›‘ å–æ¶ˆæ—§å®ä¾‹: $RUN_ID"
                  curl -fsS -X POST \
                    -H "Authorization: token $USER_PAT" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/cancel" >/dev/null 2>&1
                fi
              done <<< "$old_runs"
            fi
          fi

          # æ•è·ç»ˆæ­¢ä¿¡å·ï¼Œä¼˜é›…é€€å‡º
          trap 'echo "ğŸ›‘ æ”¶åˆ°ç»ˆæ­¢ä¿¡å·ï¼Œé€€å‡º..."; exit 1' TERM INT
          echo "âœ… è¿›å…¥ä¿æ´»å¾ªç¯ï¼Œæ•°æ®åŒæ­¥è‡³/z/Ubuï¼Œæœ€å¤§è¿è¡Œ $MAX_RUN_MINUTES åˆ†é’Ÿï¼ˆCloud Runé€‚é…ï¼‰"
          
          # ä¿æ´»ä¸»å¾ªç¯
          while true; do
            current_time=$(date +%s)
            run_mins=$(( (current_time - start_time) / 60 ))
            current_sec=$((current_time - start_time))
            
            echo "â±ï¸ è¿è¡Œæ—¶é•¿: $run_mins / $MAX_RUN_MINUTES åˆ†é’Ÿ | $(date -u)ï¼ˆCloud Runï¼‰"
            
            # æ¯5åˆ†é’Ÿç›‘æ§èµ„æº
            if [ $((current_sec % 300)) -eq 0 ]; then
              echo "===== èµ„æºç›‘æ§ï¼ˆCloud Runï¼‰ ====="
              free -h
              df -h / "${WEBDAV_MOUNT_POINT}" 2>/dev/null || df -h /
              uptime
              sudo docker ps --format "table {{.Names}}\t{{.Status}}"
            fi
            
            # å¥åº·æ£€æŸ¥ï¼ˆæ¯åˆ†é’Ÿï¼‰
            if [ $((current_sec % health_check_interval)) -eq 0 ]; then
              check_service_health "CasaOS" "http://localhost:80/api/v1/sys/version" "80"
              check_service_health "Docker" "" "2375"
              
              # æ£€æŸ¥WebDAVæŒ‚è½½ï¼ˆé€‚é…Cloud Runé‡è¿ï¼‰
              if ! mountpoint -q "${WEBDAV_MOUNT_POINT}"; then
                echo "âŒ WebDAVæŒ‚è½½æ–­å¼€ï¼Œé‡æ–°æŒ‚è½½ï¼ˆCloud Runï¼‰"
                nohup rclone mount mywebdav: "$WEBDAV_MOUNT_POINT" \
                  --config /home/runner/.rclone.conf \
                  --vfs-cache-mode full \
                  --timeout 30s \
                  --retries 3 \
                  --allow-other \
                  --daemon >/dev/null 2>&1 &
                sleep 10
              fi
              
              # é‡å¯å¼‚å¸¸æœåŠ¡
              if ! sudo systemctl is-active --quiet casaos; then
                echo "ğŸ”„ é‡å¯CasaOSï¼ˆCloud Runï¼‰"
                sudo systemctl restart casaos
                sleep 10
              fi
            fi

            # å¢é‡åŒæ­¥ï¼ˆæ¯SYNC_INTERVALåˆ†é’Ÿï¼‰
            if [ $((run_mins % SYNC_INTERVAL)) -eq 0 ] && [ $run_mins -ne $last_sync_minute ] && [ $run_mins -ne 0 ]; then
              echo "â° æ‰§è¡Œ/z/Ubuå¢é‡åŒæ­¥ï¼ˆCloud Runï¼‰"
              incremental_sync
              last_sync_minute=$run_mins
            fi

            # 300åˆ†é’Ÿæ‰§è¡Œå…¨é‡å¤‡ä»½+ç»­è·‘
            if [ $run_mins -eq 300 ]; then
              echo "â° 300åˆ†é’Ÿï¼Œ/z/Ubuå…¨é‡å¤‡ä»½+ç»­è·‘ï¼ˆCloud Runï¼‰"
              if full_backup; then
                trigger_renew
              else
                trigger_renew
              fi
            fi

            # è¾¾åˆ°ä¸Šé™é€€å‡º
            if [ $run_mins -ge $MAX_RUN_MINUTES ]; then
              echo "â¹ï¸ è¾¾åˆ°è¿è¡Œä¸Šé™ï¼Œ/z/Ubuæœ€ç»ˆå¤‡ä»½+ç»­è·‘ï¼ˆCloud Runï¼‰"
              full_backup
              trigger_renew
              exit 1
            fi
            
            sleep 30
          done

      # ========== æ­¥éª¤10ï¼šæœ€ç»ˆæ¸…ç†ï¼ˆæ— è®ºæˆè´¥ï¼‰ ==========
      - name: Step 10 - Final Cleanup (Cloud Runé€‚é…)
        if: ${{ always() }}
        run: |
          echo "===== æœ€ç»ˆç¯å¢ƒæ¸…ç†ï¼ˆCloud Runï¼‰ ====="
          # å¸è½½WebDAVï¼ˆé€‚é…Cloud Runï¼‰
          if mountpoint -q "$WEBDAV_MOUNT_POINT" 2>/dev/null; then
            echo "ğŸ”„ å¸è½½WebDAVï¼ˆCloud Runï¼‰"
            timeout 30 fusermount3 -uz "$WEBDAV_MOUNT_POINT" 2>/dev/null || sudo umount -l "$WEBDAV_MOUNT_POINT" 2>/dev/null || true
          fi
          # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
          sudo rm -rf /tmp/* /var/tmp/* /home/runner/.rclone.conf /tmp/rclone.log /tmp/rclone_test.log
          # ç§»é™¤è°ƒè¯•ç”¨æˆ·
          if id "roots" &>/dev/null; then
            sudo userdel -r roots 2>/dev/null || true
          fi
          # æ¸…ç†sudoé…ç½®
          sudo rm -f /etc/sudoers.d/runner
          # æ¸…ç†Dockerèµ„æº
          sudo docker system prune -af --filter "until=1h" >/dev/null 2>&1 || true
          echo "âœ… æ¸…ç†å®Œæˆï¼ˆCloud Runï¼‰"
