name: CasaOS-Tailscale-Full-Deploy

on:
  workflow_dispatch:
  repository_dispatch:
    types: [renew_casaos_tailscale]

jobs:
  deploy-casaos-tailscale:
    runs-on: ubuntu-24.04
    timeout-minutes: 360
    permissions:
      contents: read
      actions: write
    env:
      MAX_RUN_MINUTES: 360
      SYNC_INTERVAL: 60
      WEBDAV_MOUNT_POINT: /home/runner/webdav_mount
      BACKUP_DIRS: "/z/Ubu"  # å›ºå®šå†™å…¥/z/Ubuç›®å½•
      CASAOS_DATA: /var/lib/casaos
      DOCKER_DATA: /var/lib/docker
      KEEP_BACKUP_COUNT: 2
      EXCLUDE_DIRS: >-
        /bin /boot /dev /lib /lib32 /lib64 /lost+found /proc /root /run /sbin /sys /tmp
        /var/cache /var/log /var/tmp /var/backups /home/runner /mnt /media
        /usr/share/doc /usr/share/man /usr/share/locale /etc/ssl/certs
        /etc/fstab /etc/mtab /etc/hostname /etc/machine-id
      MOUNT_RETRY_COUNT: 5
      MOUNT_RETRY_DELAY: 5
      REPO: ${{ github.repository }}
      CURRENT_RUN_ID: ${{ github.run_id }}
      WORKFLOW_NAME: ${{ github.workflow }}

    steps:
      - name: Step 1 - System Init & Dependency Install
        run: |
          echo "===== ç³»ç»Ÿç¯å¢ƒåˆå§‹åŒ– ====="
          sudo apt update -y && sudo apt install -y rsync curl wget jq fuse3 openssl || { echo "âŒ ä¾èµ–å®‰è£…å¤±è´¥"; exit 1; }
          curl -fsSL https://rclone.org/install.sh | sudo bash
          echo "user_allow_other" | sudo tee -a /etc/fuse.conf
          echo "runner ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/runner
          sudo chmod 0440 /etc/sudoers.d/runner
          sudo mkdir -p /etc/systemd/system/docker.service.d
          echo '[Service]
          ExecStart=
          ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --log-opt max-size=10m --log-opt max-file=2' | sudo tee /etc/systemd/system/docker.service.d/override.conf
          sudo systemctl daemon-reload
          sudo rm -rf /tmp/* /var/tmp/*
          sudo apt clean && sudo apt autoclean && sudo apt autoremove -y
          sudo journalctl --vacuum-time=1d
          sudo find /var/log -type f -mtime +1 -delete
          echo "âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ"

      - name: Step 2 - Create Debug User
        run: |
          echo "===== åˆ›å»ºè°ƒè¯•ç”¨æˆ· ====="
          sudo useradd -m -s /bin/bash roots
          ROOT_PASSWORD=$(openssl rand -base64 12)
          echo "roots:$ROOT_PASSWORD" | sudo chpasswd
          sudo usermod -aG sudo roots
          echo "$ROOT_PASSWORD" | sudo tee /root/debug_password.txt > /dev/null
          sudo chmod 600 /root/debug_password.txt
          echo "âœ… è°ƒè¯•ç”¨æˆ·åˆ›å»ºå®Œæˆ | è´¦å·ï¼šroots | å¯†ç å·²ä¿å­˜è‡³ /root/debug_password.txt"

      - name: Step 3 - Mount WebDAV (Fix /z/Ubu Write)
        env:
          WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
          WEBDAV_USER: ${{ secrets.WEBDAV_USER }}
          WEBDAV_PASSWORD: ${{ secrets.WEBDAV_PASSWORD }}
        run: |
          echo "===== æŒ‚è½½ WebDAV å­˜å‚¨ï¼ˆæŒ‡å®š/z/Ubuå†™å…¥ï¼‰ ====="
          if [[ ! "$WEBDAV_URL" =~ ^https?:// ]]; then
            echo "âŒ WebDAV URL æ ¼å¼é”™è¯¯ï¼Œå¿…é¡»ä»¥ http:// æˆ– https:// å¼€å¤´"
            exit 1
          fi
          WEBDAV_URL_FIXED="${WEBDAV_URL%/}/"
          echo "ğŸ”§ ä¿®æ­£åçš„WebDAV URL: $WEBDAV_URL_FIXED"

          mkdir -p "$WEBDAV_MOUNT_POINT"
          
          # é…ç½®rclone
          rclone config create mywebdav webdav \
            url="$WEBDAV_URL_FIXED" \
            vendor="other" \
            user="$WEBDAV_USER" \
            pass="$WEBDAV_PASSWORD" \
            --obscure \
            --config /home/runner/.rclone.conf
            
          # æµ‹è¯•åŸºç¡€è¿æ¥
          echo "ğŸ” æµ‹è¯•WebDAVè¿æ¥..."
          if ! rclone ls mywebdav: --config /home/runner/.rclone.conf >/dev/null 2>&1; then
            echo "âŒ WebDAV åŸºç¡€è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥URL/è´¦å·å¯†ç "
            exit 1
          fi

          # åå°æŒ‚è½½WebDAV
          nohup rclone mount mywebdav: "$WEBDAV_MOUNT_POINT" \
            --config /home/runner/.rclone.conf \
            --vfs-cache-mode full \
            --vfs-cache-max-age 24h \
            --vfs-cache-max-size 10G \
            --buffer-size 64M \
            --daemon-timeout 5m \
            --allow-other \
            --allow-non-empty \
            --umask 022 \
            --log-file /tmp/rclone.log \
            --log-level INFO >/dev/null 2>&1 &
          
          # æŒ‚è½½éªŒè¯ï¼ˆé‡ç‚¹ï¼šç›´æ¥æµ‹è¯•/z/Ubuç›®å½•å†™å…¥ï¼‰
          sleep 15
          MOUNT_SUCCESS=false
          WRITE_TEST_SUCCESS=false
          
          for i in $(seq 1 $MOUNT_RETRY_COUNT); do
            echo "ğŸ” æ£€æŸ¥ WebDAV æŒ‚è½½çŠ¶æ€ (å°è¯• $i/$MOUNT_RETRY_COUNT)..."
            
            if timeout 10 ls "$WEBDAV_MOUNT_POINT" >/dev/null 2>&1; then
              echo "âœ… ç›®å½•å¯è¯»ï¼ŒéªŒè¯/z/Ubuå†™å…¥æƒé™..."
              
              # ========== å…³é”®ä¿®æ”¹1ï¼šç›´æ¥åˆ›å»º/z/Ubuå¹¶æµ‹è¯•å†™å…¥ ==========
              TEST_DIR="$WEBDAV_MOUNT_POINT/z/Ubu/test"
              mkdir -p "$TEST_DIR"  # æ˜¾å¼åˆ›å»º/z/Ubu/testç›®å½•
              test_file="$TEST_DIR/mount_test_$(date -u +%s).txt"
              echo "mount_test_$(date -u +%s)" > "$test_file"
              
              # éªŒè¯æ–‡ä»¶å†™å…¥æˆåŠŸ
              if [ -f "$test_file" ]; then
                # è¿œç¨‹éªŒè¯/z/Ubuç›®å½•ä¸‹çš„æ–‡ä»¶
                if rclone ls mywebdav:z/Ubu/test/ --config /home/runner/.rclone.conf | grep -q "$(basename $test_file)"; then
                  # æ¸…ç†æµ‹è¯•æ–‡ä»¶
                  rm -rf "$WEBDAV_MOUNT_POINT/z/Ubu/test"
                  rclone delete mywebdav:z/Ubu/test/ --config /home/runner/.rclone.conf >/dev/null 2>&1
                  MOUNT_SUCCESS=true
                  WRITE_TEST_SUCCESS=true
                  echo "âœ… /z/Ubu ç›®å½•å†™å…¥éªŒè¯é€šè¿‡"
                  break
                fi
              fi
              
              rm -rf "$WEBDAV_MOUNT_POINT/z/Ubu/test"
            fi
            
            echo "âš ï¸ /z/Ubu å†™å…¥éªŒè¯å¤±è´¥ï¼Œç­‰å¾… $MOUNT_RETRY_DELAY ç§’åé‡è¯•"
            sleep $MOUNT_RETRY_DELAY
          done
          
          if [ "$WRITE_TEST_SUCCESS" = "false" ]; then
            echo "âŒ /z/Ubu ç›®å½•å†™å…¥éªŒè¯å¤±è´¥"
            echo "ğŸ“Š æŒ‚è½½æ—¥å¿—:"
            cat /tmp/rclone.log 2>/dev/null || echo "æ— æ—¥å¿—æ–‡ä»¶"
            echo "WEBDAV_AVAILABLE=false" >> "$GITHUB_ENV"
            exit 0
          fi
          
          echo "WEBDAV_AVAILABLE=true" >> "$GITHUB_ENV"
          
          # åˆå§‹åŒ–/z/Ubuå¤‡ä»½ç›®å½•
          target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
          mkdir -p "${target_path}/tmp_incremental" "${target_path}/sync_logs"
          if [ -n "$(ls -A "${target_path}" 2>/dev/null)" ]; then
            echo "âœ… æ£€æµ‹åˆ°/z/Ubuå·²æœ‰å¤‡ä»½æ•°æ®"
            echo "HAS_z_Ubu=true" >> "$GITHUB_ENV"
          else
            echo "âš ï¸ åˆå§‹åŒ–/z/Ubuå¤‡ä»½ç›®å½•"
            echo "HAS_z_Ubu=false" >> "$GITHUB_ENV"
          fi

      - name: Step 4 - Smart Data Restore
        if: ${{ env.WEBDAV_AVAILABLE == 'true' }}
        run: |
          echo "===== ä»/z/Ubuæ¢å¤æ•°æ® ====="
          RESTORE_DONE=false
          
          RESTORE_DIRS=(
            "/var/lib/casaos"
            "/var/lib/docker/volumes"
            "/opt/casaos"
          )
          
          target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
          if [ "${HAS_z_Ubu}" = "true" ]; then
            latest_full_backup=$(ls -dt "${target_path}"/[0-9]* 2>/dev/null | head -n 1)
            incremental_dir="${target_path}/tmp_incremental"
            
            if [ -n "$latest_full_backup" ] && [ -d "$latest_full_backup" ]; then
              echo "ğŸ”„ ä»/z/Ubuå…¨é‡å¤‡ä»½æ¢å¤ï¼š$latest_full_backup"
              restore_source="${latest_full_backup}/"
            elif [ -n "$(ls -A "${incremental_dir}" 2>/dev/null)" ]; then
              echo "ğŸ”„ ä»/z/Ubuå¢é‡ç›®å½•æ¢å¤ï¼š$incremental_dir"
              restore_source="${incremental_dir}/"
            else
              echo "âš ï¸ /z/Ubuæ— æœ‰æ•ˆå¤‡ä»½ï¼Œè·³è¿‡æ¢å¤"
              RESTORE_DONE=false
            fi
            
            if [ -n "$restore_source" ]; then
              for restore_dir in "${RESTORE_DIRS[@]}"; do
                if [ -d "${restore_source}${restore_dir#/}" ]; then
                  echo "ğŸ”„ æ¢å¤ç›®å½•: $restore_dir"
                  sudo mkdir -p "$(dirname "${restore_dir}")"
                  
                  EXCLUDE_PARAMS=()
                  for excl in $EXCLUDE_DIRS; do
                    EXCLUDE_PARAMS+=("--exclude=${excl}")
                  done
                  
                  sudo rsync -av --copy-links --sparse --numeric-ids \
                    "${EXCLUDE_PARAMS[@]}" \
                    "${restore_source}${restore_dir#/}/" "${restore_dir}/"
                fi
              done
              
              echo "âœ… /z/Ubuæ•°æ®æ¢å¤å®Œæˆ"
              RESTORE_DONE=true
            fi
          fi
          
          echo "DATA_RESTORED=${RESTORE_DONE}" >> "$GITHUB_ENV"

      - name: Step 5 - Install or Skip CasaOS
        run: |
          echo "===== éƒ¨ç½² CasaOS æœåŠ¡ ====="
          if [ -d "${CASAOS_DATA}" ] && [ "${DATA_RESTORED}" = "true" ]; then
            echo "âœ… æ£€æµ‹åˆ°æ¢å¤æ•°æ®ï¼Œè·³è¿‡å®‰è£…"
          else
            curl -fsSL https://get.casaos.io | sudo bash || { echo "âŒ CasaOS å®‰è£…å¤±è´¥"; exit 1; }
            echo "âœ… CasaOS å®‰è£…å®Œæˆ"
          fi

      - name: Step 6 - Start Docker & CasaOS with Retry
        run: |
          echo "===== å¯åŠ¨æ ¸å¿ƒæœåŠ¡ ====="
          sudo systemctl enable --now docker casaos
          
          max_retries=10
          retry_count=0
          services=("docker" "casaos")
          
          while [ $retry_count -lt $max_retries ]; do
            all_active=true
            
            for service in "${services[@]}"; do
              if ! sudo systemctl is-active --quiet "$service"; then
                echo "ğŸ”„ æœåŠ¡ $service æœªå°±ç»ªï¼Œé‡è¯•ä¸­... ($retry_count/$max_retries)"
                all_active=false
                break
              fi
            done
            
            if [ "$all_active" = "true" ]; then
              echo "âœ… æ‰€æœ‰æœåŠ¡å·²æˆåŠŸå¯åŠ¨"
              break
            fi
            
            ((retry_count++))
            sleep 5
          done
          
          if [ "$all_active" = "false" ]; then
            echo "âŒ æœåŠ¡å¯åŠ¨è¶…æ—¶"
            for service in "${services[@]}"; do
              echo "ğŸ“Š $service çŠ¶æ€:"
              sudo systemctl status "$service" --no-pager
            done
            exit 1
          fi
          
          echo "â³ ç­‰å¾… CasaOS API å°±ç»ª..."
          timeout=60
          start_time=$(date +%s)
          
          while true; do
            if curl -m 5 -s http://localhost:80/api/v1/sys/version >/dev/null 2>&1; then
              echo "âœ… CasaOS API å·²å°±ç»ª"
              break
            fi
            
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ CasaOS API å¯åŠ¨è¶…æ—¶"
              exit 1
            fi
            
            sleep 2
            echo -n "."
          done

      - name: Step 7 - Deploy Tailscale (Only IPv4)
        env:
          TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
        run: |
          echo "===== é…ç½® Tailscale å†…ç½‘ç©¿é€ï¼ˆä»…IPv4ï¼‰ ====="
          if [ -z "$TAILSCALE_AUTH_KEY" ]; then
            echo "âš ï¸ æœªé…ç½® TAILSCALE_AUTH_KEYï¼Œè·³è¿‡ç»„ç½‘"
            echo "TAILSCALE_IP=" >> "$GITHUB_ENV"
            exit 0
          fi
          
          curl -fsSL https://tailscale.com/install.sh | sudo bash
          
          HOSTNAME="casaos-${GITHUB_RUN_ID:0:12}"
          # ========== å…³é”®ä¿®æ”¹2ï¼šTailscale ä»…ä½¿ç”¨IPv4 ==========
          sudo tailscale up --authkey="$TAILSCALE_AUTH_KEY" \
            --accept-routes \
            --accept-dns \
            --hostname="$HOSTNAME" \
            --advertise-routes=0.0.0.0/0 \  # ä»…å£°æ˜IPv4è·¯ç”±
            --force-ipv4=true \              # å¼ºåˆ¶ä½¿ç”¨IPv4
            --timeout=30s                    # æ— éœ€|| trueï¼Œæ— IPv6è­¦å‘Š
            
          # è·å–Tailscale IPv4åœ°å€
          max_retries=5
          retry_count=0
          TAILSCALE_IP=""
          
          while [ $retry_count -lt $max_retries ]; do
            TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null | head -n1)
            if [ -n "$TAILSCALE_IP" ]; then
              echo "âœ… Tailscale IPv4 åœ°å€ï¼š$TAILSCALE_IP"
              echo "TAILSCALE_IP=${TAILSCALE_IP}" >> "$GITHUB_ENV"
              break
            fi
            
            echo "â³ ç­‰å¾… Tailscale è·å– IPv4 åœ°å€... ($retry_count/$max_retries)"
            ((retry_count++))
            sleep 5
          done
          
          if [ -z "$TAILSCALE_IP" ]; then
            echo "âŒ Tailscale ç»„ç½‘å¤±è´¥ï¼Œæœªè·å–åˆ°IPv4åœ°å€"
            echo "ğŸ“Š Tailscale çŠ¶æ€:"
            sudo tailscale status --json
            echo "TAILSCALE_IP=" >> "$GITHUB_ENV"
          fi

      - name: Step 8 - Print Access Info
        run: |
          echo "===== æœåŠ¡è®¿é—®ä¿¡æ¯ ====="
          PUBLIC_IP=$(curl -s --max-time 10 ifconfig.me || echo "è·å–å¤±è´¥")
          
          echo "ğŸ”— å…¬ç½‘ IPv4 è®¿é—®ï¼šhttp://$PUBLIC_IP"
          
          if [ -n "$TAILSCALE_IP" ]; then
            echo "ğŸ”’ Tailscale IPv4 è®¿é—®ï¼šhttp://$TAILSCALE_IP"
            echo "ğŸŒ Tailscale çŠ¶æ€é¡µï¼šhttps://login.tailscale.com/admin/machines/$TAILSCALE_IP"
          fi
          
          echo "ğŸ‘¤ è°ƒè¯•ç”¨æˆ·ï¼šrootsï¼ˆå¯†ç ä½äº /root/debug_password.txtï¼‰"
          echo "âš ï¸ å®‰å…¨æç¤ºï¼šç«‹å³ä¿®æ”¹rootså¯†ç ï¼Œä¸è¦æš´éœ²å…¬ç½‘IP"

      - name: Step 9 - Keep Alive + Sync + Backup + Renew
        env:
          USER_PAT: ${{ secrets.USER_PAT }}
        shell: bash
        run: |
          echo "===== è¿›å…¥ä¿æ´»å¾ªç¯ï¼ˆæ•°æ®åŒæ­¥è‡³/z/Ubuï¼‰ ====="
          start_time=$(date +%s)
          last_sync_minute=-$SYNC_INTERVAL
          health_check_interval=60

          trigger_renew() {
            echo "===== è§¦å‘ç»­è·‘å·¥ä½œæµ ====="
            if [ -z "$USER_PAT" ] || [ -z "$REPO" ]; then
              echo "âŒ ç¼ºå°‘USER_PATï¼Œæ— æ³•ç»­è·‘"
              return 1
            fi
            
            payload=$(cat <<EOF
            {
              "event_type": "renew_casaos_tailscale",
              "client_payload": {
                "previous_run_id": "$CURRENT_RUN_ID",
                "workflow_name": "$WORKFLOW_NAME"
              }
            }
            EOF
            )
            
            response=$(curl -fsS -w "HTTP_STATUS:%{http_code}" \
              -X POST \
              -H "Authorization: token $USER_PAT" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              "https://api.github.com/repos/$REPO/dispatches" \
              -d "$payload" 2>&1)
            
            http_status=$(echo "$response" | grep -oP 'HTTP_STATUS:\K\d+')
            
            if [ "$http_status" = "204" ]; then
              echo "âœ… ç»­è·‘è§¦å‘æˆåŠŸ"
              exit 0
            else
              echo "âŒ ç»­è·‘è§¦å‘å¤±è´¥ (HTTP $http_status)"
              return 1
            fi
          }

          clean_docker_garbage() {
            echo "===== Docker åƒåœ¾æ¸…ç† ====="
            sudo docker stop $(sudo docker ps -aq -f status=exited 2>/dev/null) 2>/dev/null || true
            sudo docker rm $(sudo docker ps -aq -f status=exited 2>/dev/null) 2>/dev/null || true
            sudo docker system prune -af --filter "until=24h" >/dev/null 2>&1 || true
            sudo docker volume prune -f --filter "until=24h" >/dev/null 2>&1 || true
          }

          clean_old_backups() {
            if [ "${WEBDAV_AVAILABLE:-false}" != "true" ]; then return 1; fi
            echo "===== æ¸…ç†/z/Ubuæ—§å¤‡ä»½ ====="
            target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
            backup_folders=$(find "${target_path}" -maxdepth 1 -type d -name '[0-9]*' 2>/dev/null | sort -r)
            total_backups=$(echo "$backup_folders" | wc -l)
            to_delete=$((total_backups - KEEP_BACKUP_COUNT))
            
            if [ $to_delete -gt 0 ]; then
              count=0
              while IFS= read -r folder; do
                if [ $count -ge $to_delete ]; then break; fi
                echo "ğŸ—‘ï¸ åˆ é™¤/z/Ubuæ—§å¤‡ä»½: $(basename "${folder}")"
                sudo rm -rf "$folder"
                ((count++))
              done <<< "$backup_folders"
            fi
          }

          incremental_sync() {
            if [ "${WEBDAV_AVAILABLE:-false}" != "true" ]; then return 1; fi
            echo "===== å¢é‡åŒæ­¥è‡³/z/Ubu ====="
            SYNC_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            
            target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
            sync_dir="${target_path}/tmp_incremental"
            log_file="${target_path}/sync_logs/sync_$(date -u +%Y%m%d_%H%M%S).log"
            mkdir -p "$(dirname "${log_file}")"
            
            SYNC_DIRS=(
              "/var/lib/casaos"
              "/var/lib/docker/volumes"
              "/opt/casaos"
              "/etc/casaos"
            )
            
            EXCLUDE_PARAMS=("--exclude=${WEBDAV_MOUNT_POINT}")
            for excl in $EXCLUDE_DIRS; do
              EXCLUDE_PARAMS+=("--exclude=${excl}")
            done
            
            sync_success=true
            for sync_dir_entry in "${SYNC_DIRS[@]}"; do
              if [ -d "$sync_dir_entry" ]; then
                echo "ğŸ”„ åŒæ­¥: $sync_dir_entry" >> "$log_file"
                sudo rsync -av --update --compress --copy-links --sparse --numeric-ids \
                  "${EXCLUDE_PARAMS[@]}" \
                  "${sync_dir_entry}/" "${sync_dir}/${sync_dir_entry#/}/" >> "$log_file" 2>&1
                  
                if [ $? -ne 0 ]; then
                  sync_success=false
                fi
              fi
            done
            
            if $sync_success; then
              echo "incremental_sync_time=${SYNC_TIME}" > "${sync_dir}/sync_info.txt"
              echo "âœ… /z/Ubuå¢é‡åŒæ­¥å®Œæˆ"
              return 0
            else
              echo "âŒ /z/Ubuå¢é‡åŒæ­¥å¤±è´¥"
              return 1
            fi
          }

          full_backup() {
            if [ "${WEBDAV_AVAILABLE:-false}" != "true" ]; then return 1; fi
            clean_docker_garbage
            echo "===== å…¨é‡å¤‡ä»½è‡³/z/Ubu ====="
            BACKUP_SUCCESS=false
            
            target_path="${WEBDAV_MOUNT_POINT}/z/Ubu"
            full_backup_dir="${target_path}/$(date -u +%Y%m%d_%H%M%S)"
            incremental_dir="${target_path}/tmp_incremental"
            mkdir -p "$full_backup_dir"
            
            if [ -n "$(ls -A "${incremental_dir}" 2>/dev/null)" ]; then
              backup_source="${incremental_dir}/"
            else
              backup_source="/"
            fi
            
            BACKUP_DIRS=(
              "/var/lib/casaos"
              "/var/lib/docker/volumes"
              "/opt/casaos"
              "/etc/casaos"
            )
            
            EXCLUDE_PARAMS=("--exclude=${WEBDAV_MOUNT_POINT}")
            for excl in $EXCLUDE_DIRS; do
              EXCLUDE_PARAMS+=("--exclude=${excl}")
            done
            
            backup_success=true
            for backup_dir in "${BACKUP_DIRS[@]}"; do
              source_path="${backup_source}${backup_dir#/}"
              if [ -d "$source_path" ]; then
                echo "ğŸ“¦ å¤‡ä»½: $backup_dir"
                mkdir -p "${full_backup_dir}${backup_dir}"
                sudo rsync -av --copy-links --sparse --numeric-ids \
                  "${EXCLUDE_PARAMS[@]}" \
                  "${source_path}/" "${full_backup_dir}${backup_dir}/" >/dev/null 2>&1
                  
                if [ $? -ne 0 ]; then
                  backup_success=false
                fi
              fi
            done
            
            if $backup_success; then
              printf "backup_time=%s\nrunner_id=%s\ntype=full_backup\n" \
                "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
                "$CURRENT_RUN_ID" > "${full_backup_dir}/backup_info.txt"
              echo "âœ… /z/Ubuå…¨é‡å¤‡ä»½å®Œæˆï¼š$full_backup_dir"
              clean_old_backups
              BACKUP_SUCCESS=true
            else
              sudo rm -rf "$full_backup_dir"
            fi
            
            $BACKUP_SUCCESS
          }

          check_service_health() {
            local service_name=$1
            local url=$2
            local port=$3
            
            if [ -n "$port" ] && ! sudo lsof -i :"$port" >/dev/null 2>&1; then
              echo "âŒ $service_name ç«¯å£ $port æœªç›‘å¬"
              return 1
            fi
            
            if [ -n "$url" ] && ! curl -m 5 -s "$url" >/dev/null 2>&1; then
              echo "âŒ $service_name HTTP ä¸å¯ç”¨"
              return 1
            fi
            
            echo "âœ… $service_name å¥åº·"
            return 0
          }

          # å–æ¶ˆæ—§å·¥ä½œæµ
          if [ -n "$USER_PAT" ]; then
            echo "===== å–æ¶ˆæ—§å·¥ä½œæµå®ä¾‹ ====="
            response=$(curl -fsS \
              -H "Authorization: token $USER_PAT" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/actions/runs?status=in_progress&per_page=100")
            
            old_runs=$(echo "$response" | jq -r --arg WF_NAME "$WORKFLOW_NAME" --arg CURRENT_ID "$CURRENT_RUN_ID" \
              '.workflow_runs[] | select(.name == $WF_NAME and .id != ($CURRENT_ID | tonumber)) | .id')
            
            if [ -n "$old_runs" ] && [ "$old_runs" != "null" ]; then
              while IFS= read -r RUN_ID; do
                if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
                  echo "ğŸ›‘ å–æ¶ˆæ—§å®ä¾‹: $RUN_ID"
                  curl -fsS -X POST \
                    -H "Authorization: token $USER_PAT" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/cancel" >/dev/null 2>&1
                fi
              done <<< "$old_runs"
            fi
          fi

          trap 'echo "ğŸ›‘ æ”¶åˆ°ç»ˆæ­¢ä¿¡å·ï¼Œé€€å‡º..."; exit 1' TERM INT
          echo "âœ… è¿›å…¥ä¿æ´»å¾ªç¯ï¼Œæ•°æ®åŒæ­¥è‡³/z/Ubuï¼Œæœ€å¤§è¿è¡Œ $MAX_RUN_MINUTES åˆ†é’Ÿ"
          
          while true; do
            current_time=$(date +%s)
            run_mins=$(( (current_time - start_time) / 60 ))
            current_sec=$((current_time - start_time))
            
            echo "â±ï¸ è¿è¡Œæ—¶é•¿: $run_mins / $MAX_RUN_MINUTES åˆ†é’Ÿ | $(date -u)"
            
            if [ $((current_sec % 300)) -eq 0 ]; then
              echo "===== èµ„æºç›‘æ§ ====="
              free -h
              df -h / "${WEBDAV_MOUNT_POINT}" 2>/dev/null || df -h /
              uptime
              sudo docker ps --format "table {{.Names}}\t{{.Status}}"
            fi
            
            if [ $((current_sec % health_check_interval)) -eq 0 ]; then
              check_service_health "CasaOS" "http://localhost:80/api/v1/sys/version" "80"
              check_service_health "Docker" "" "2375"
              
              if ! mountpoint -q "${WEBDAV_MOUNT_POINT}"; then
                echo "âŒ WebDAVæŒ‚è½½æ–­å¼€ï¼Œé‡æ–°æŒ‚è½½"
                nohup rclone mount mywebdav: "$WEBDAV_MOUNT_POINT" --config /home/runner/.rclone.conf --vfs-cache-mode full --allow-other --daemon >/dev/null 2>&1 &
                sleep 10
              fi
              
              if ! sudo systemctl is-active --quiet casaos; then
                echo "ğŸ”„ é‡å¯CasaOS"
                sudo systemctl restart casaos
                sleep 10
              fi
            fi

            if [ $((run_mins % SYNC_INTERVAL)) -eq 0 ] && [ $run_mins -ne $last_sync_minute ] && [ $run_mins -ne 0 ]; then
              echo "â° æ‰§è¡Œ/z/Ubuå¢é‡åŒæ­¥"
              incremental_sync
              last_sync_minute=$run_mins
            fi

            if [ $run_mins -eq 300 ]; then
              echo "â° 300åˆ†é’Ÿï¼Œ/z/Ubuå…¨é‡å¤‡ä»½+ç»­è·‘"
              if full_backup; then
                trigger_renew
              else
                trigger_renew
              fi
            fi

            if [ $run_mins -ge $MAX_RUN_MINUTES ]; then
              echo "â¹ï¸ è¾¾åˆ°è¿è¡Œä¸Šé™ï¼Œ/z/Ubuæœ€ç»ˆå¤‡ä»½+ç»­è·‘"
              full_backup
              trigger_renew
              exit 1
            fi
            
            sleep 30
          done

      - name: Step 10 - Final Cleanup
        if: ${{ always() }}
        run: |
          echo "===== æœ€ç»ˆç¯å¢ƒæ¸…ç† ====="
          if mountpoint -q "$WEBDAV_MOUNT_POINT" 2>/dev/null; then
            echo "ğŸ”„ å¸è½½WebDAV"
            timeout 30 fusermount3 -uz "$WEBDAV_MOUNT_POINT" 2>/dev/null || sudo umount -l "$WEBDAV_MOUNT_POINT" 2>/dev/null || true
          fi
          sudo rm -rf /tmp/* /var/tmp/* /home/runner/.rclone.conf /tmp/rclone.log
          if id "roots" &>/dev/null; then
            sudo userdel -r roots 2>/dev/null || true
          fi
          sudo rm -f /etc/sudoers.d/runner
          sudo docker system prune -af --filter "until=1h" >/dev/null 2>&1 || true
          echo "âœ… æ¸…ç†å®Œæˆ"
