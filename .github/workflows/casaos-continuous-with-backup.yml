name: Docker-TTA-Full-Snapshot-Backup-Restore
on:
  workflow_dispatch:
  repository_dispatch:
    types: [renew_docker_tta_snapshot]

# 全局配置优化：减少重复、提升并行性
defaults:
  run:
    shell: bash
    working-directory: /home/runner

# 全局环境变量（关键：timeout-minutes可直接引用全局env）
env:
  # ========== 基础配置（可按需修改） ==========
  OS_VERSION: noble
  TIMEZONE: Asia/Shanghai
  LOCALE: zh_CN.UTF-8
  MAX_RUN_MINUTES: 360          # 全局定义，确保timeout-minutes能引用
  RETRY_TIMES: 3                # 关键操作重试次数
  RETRY_INTERVAL: 5             # 重试间隔（秒）
  KEEP_SNAPSHOTS: 3             # 保留最近快照数量
  # ========== 备份/恢复核心配置 ==========
  WEBDAV_SNAPSHOT_DIR: "/z/Ubu"
  DOCKER_TTA_FULL_DIRS: |
    /var/lib/docker
    /etc/docker
    /usr/bin/docker
    /usr/bin/docker-compose
    /usr/bin/containerd
    /usr/bin/ctr
    /usr/lib/systemd/system/docker.service
    /usr/lib/systemd/system/docker.socket
    /usr/lib/systemd/system/containerd.service
    /etc/systemd/system/docker.service.d
    /etc/containerd
    /var/run/docker
    /var/run/containerd
    /etc/crictl.yaml
    /usr/share/keyrings/docker-archive-keyring.gpg
    /etc/apt/sources.list.d/docker.list
    /TTA
  EXCLUDE_RULES: >-
    --exclude=*.log --exclude=*.tmp --exclude=*.swp
    --exclude=/var/lib/docker/containers/*/*.log
    --exclude=/var/lib/docker/overlay2/*/tmp
    --exclude=/var/lib/docker/tmp
    --exclude=/var/lib/docker/buildkit/*
    --exclude=/var/lib/docker/tmpfs/*
    --exclude=/var/lib/docker/volumes/*/_data/tmp/*
  # ========== 传输优化配置 ==========
  RCLONE_BUFFER_SIZE: 50M   # 降低缓冲区，适配更多环境
  RCLONE_CHUNK_SIZE: 20M    # 降低分块，减少内存占用
  RCLONE_TRANSFERS: 4       # 并行传输数
  RCLONE_RETRIES: 3         # rclone重试次数
  # ========== 路径常量 ==========
  RCLONE_CONF_PATH: /home/runner/.rclone.conf
  TMP_DIR: /tmp/docker-tta-snapshot
  # ========== Docker配置 ==========
  DOCKER_REGISTRY_MIRROR: "https://docker.mirrors.ustc.edu.cn"
  DOCKER_LOG_MAX_SIZE: "100m"
  DOCKER_LOG_MAX_FILE: "3"

jobs:
  docker-tta-snapshot:
    runs-on: ubuntu-24.04
    # 修复：使用全局env变量，语法正确（或直接写360避免引用）
    timeout-minutes: ${{ env.MAX_RUN_MINUTES }}
    permissions:  # 最小权限原则
      contents: read
      actions: write  # 仅给续跑需要的权限
    # 修复：“秘密”改为英文secrets（核心错误）
    secrets:
      WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
      WEBDAV_USER: ${{ secrets.WEBDAV_USER }}
      WEBDAV_PASSWORD: ${{ secrets.WEBDAV_PASSWORD }}
      USER_PAT: ${{ secrets.USER_PAT }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      ROOTS_PASSWORD: ${{ secrets.ROOTS_PASSWORD }}

    steps:
      - name: 1. Env Init & Install Dependencies
        run: |
          set -euo pipefail
          # 创建临时目录
          sudo mkdir -p $TMP_DIR /TTA && sudo chmod 700 $TMP_DIR
          
          # 优化：使用阿里云Ubuntu源，速度更快
          sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak
          cat <<EOF | sudo tee /etc/apt/sources.list
          deb http://mirrors.aliyun.com/ubuntu/ $OS_VERSION main restricted universe multiverse
          deb http://mirrors.aliyun.com/ubuntu/ $OS_VERSION-updates main restricted universe multiverse
          deb http://mirrors.aliyun.com/ubuntu/ $OS_VERSION-security main restricted universe multiverse
          deb http://mirrors.aliyun.com/ubuntu/ $OS_VERSION-backports main restricted universe multiverse
          EOF
          
          # 安装基础依赖（增加pigz提升压缩速度）
          sudo apt update -y && sudo apt install -y \
            curl wget jq fuse3 tar gzip pigz locales openssl dnsutils apt-transport-https \
            ca-certificates gnupg lsb-release file lsof util-linux coreutils
          
          # 配置本地化
          sudo locale-gen $LOCALE && export LC_ALL=$LOCALE LANG=$LOCALE
          sudo timedatectl set-timezone $TIMEZONE
          
          # 安装rclone（带重试）
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            if curl -fsSL https://rclone.org/install.sh | sudo bash; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ Rclone安装失败，退出" && exit 1
            fi
            sleep $RETRY_INTERVAL
          done
          
          # 安全优化：sudo免密仅限定必要命令，而非ALL
          if grep -q "requiretty" /etc/sudoers 2>/dev/null; then
            sudo sed -i 's/^Defaults requiretty/#Defaults requiretty/' /etc/sudoers
          fi
          cat <<EOF | sudo tee /etc/sudoers.d/runner
          runner ALL=(ALL) NOPASSWD: /usr/bin/systemctl, /usr/bin/apt, /usr/bin/chown, /usr/bin/chmod, /usr/bin/rm, /usr/bin/mkdir, /usr/bin/pkill, /usr/bin/tar, /usr/bin/rclone, /usr/bin/docker, /usr/bin/containerd, /usr/bin/ctr, /usr/bin/usermod, /usr/bin/chpasswd, /usr/bin/useradd, /usr/bin/timedatectl, /usr/bin/locale-gen, /usr/bin/mv, /usr/bin/tee, /usr/bin/grep, /usr/bin/sed, /usr/bin/umount, /usr/bin/sync, /usr/bin/du, /usr/bin/stat, /usr/bin/md5sum
          EOF
          sudo chmod 0440 /etc/sudoers.d/runner
          
          # 网络检测（脱敏输出）
          echo "✅ 环境初始化完成，网络检测："
          curl -fsSL https://github.com >/dev/null 2>&1 && echo "✅ GitHub 连通正常"
          curl -fsSL https://docker.com >/dev/null 2>&1 && echo "✅ Docker 官网 连通正常"

      - name: 2. Create Roots User (Optional)
        run: |
          set -euo pipefail
          if ! id "roots" &>/dev/null; then
            sudo useradd -m -s /bin/bash roots
            # 安全优化：密码处理脱敏
            ROOTS_PWD="${{ secrets.ROOTS_PASSWORD }}"
            if [ -z "$ROOTS_PWD" ]; then
              ROOTS_PWD=$(openssl rand -base64 16)
              echo "ℹ️ 自动生成roots密码（仅本次可见）：$ROOTS_PWD"
            fi
            echo "roots:$ROOTS_PWD" | sudo chpasswd
            sudo usermod -aG sudo,docker roots
            unset ROOTS_PWD  # 清理环境变量
            echo "✅ roots 用户创建完成"
          else
            echo "ℹ️ roots 用户已存在，跳过"
          fi

      - name: 3. Configure WebDAV (Rclone Full Config)
        id: webdav-config
        run: |
          set -euo pipefail
          # 检测WebDAV密钥完整性
          if [ -z "${{ secrets.WEBDAV_URL }}" ] || [ -z "${{ secrets.WEBDAV_USER }}" ] || [ -z "${{ secrets.WEBDAV_PASSWORD }}" ]; then
            echo "❌ WebDAV 密钥未配置，跳过备份/恢复"
            echo "webdav_available=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # 配置Rclone（安全优化：更严格的权限）
          ENCRYPTED_PASS=$(rclone obscure "${{ secrets.WEBDAV_PASSWORD }}")
          cat <<EOF | sudo tee $RCLONE_CONF_PATH
          [mywebdav]
          type = webdav
          url = ${{ secrets.WEBDAV_URL }}
          vendor = generic
          user = ${{ secrets.WEBDAV_USER }}
          pass = $ENCRYPTED_PASS
          buffer_size = $RCLONE_BUFFER_SIZE
          chunk_size = $RCLONE_CHUNK_SIZE
          retries = $RCLONE_RETRIES
          low_level_retries = 5
          EOF
          sudo chown runner:runner $RCLONE_CONF_PATH && sudo chmod 400 $RCLONE_CONF_PATH  # 仅属主可读
          
          # 检测WebDAV连通性+可写性（带重试）
          echo "✅ 检测WebDAV连通性..."
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            if rclone ls mywebdav:/ --config $RCLONE_CONF_PATH >/dev/null 2>&1; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ WebDAV 连接失败"
              echo "webdav_available=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep $RETRY_INTERVAL
          done
          
          echo "✅ 检测WebDAV可写性..."
          TEST_FILE=$(mktemp -p $TMP_DIR)
          echo "docker-tta-snapshot-test" | sudo tee $TEST_FILE
          if ! rclone copy $TEST_FILE mywebdav:/ --config $RCLONE_CONF_PATH; then
            echo "❌ WebDAV 无写入权限"
            echo "webdav_available=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          sudo rclone delete mywebdav:/$(basename $TEST_FILE) --config $RCLONE_CONF_PATH && rm -f $TEST_FILE
          
          # 查找最新快照（优化：按时间排序更精准）
          WEBDAV_SNAPSHOT_DIR_CLEAN=$(echo "$WEBDAV_SNAPSHOT_DIR" | sed 's/\/$//')
          LATEST_SNAPSHOT=$(rclone ls mywebdav:${WEBDAV_SNAPSHOT_DIR_CLEAN} --config $RCLONE_CONF_PATH \
            | grep "docker-tta-full-snapshot-.*.tar.gz" | awk -F '/' '{print $NF}' \
            | sort -r | head -n1)
          
          if [ -n "$LATEST_SNAPSHOT" ]; then
            echo "latest_snapshot=${WEBDAV_SNAPSHOT_DIR_CLEAN}/${LATEST_SNAPSHOT}" >> "$GITHUB_OUTPUT"
            echo "✅ 找到最新Docker+TTA完整快照：$LATEST_SNAPSHOT"
          else
            echo "ℹ️ 未找到Docker+TTA快照，将安装全新官方Docker"
          fi
          echo "webdav_available=true" >> "$GITHUB_OUTPUT"
          echo "WEBDAV_SNAPSHOT_DIR_CLEAN=${WEBDAV_SNAPSHOT_DIR_CLEAN}" >> "$GITHUB_ENV"

      - name: 4. Restore Docker+TTA Full Snapshot (1:1 完整恢复)
        if: ${{ steps.webdav-config.outputs.webdav_available == 'true' && steps.webdav-config.outputs.latest_snapshot != '' }}
        id: restore
        run: |
          set -euo pipefail
          SNAPSHOT_PATH=${{ steps.webdav-config.outputs.latest_snapshot }}
          echo "===== 开始1:1完整恢复Docker+TTA快照：$SNAPSHOT_PATH ====="
          
          # 停止Docker服务（带重试）
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            sudo systemctl stop docker containerd docker.socket 2>/dev/null && sudo pkill -9 docker containerd ctr dockerd 2>/dev/null
            if ! pgrep docker >/dev/null 2>&1; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ 无法停止Docker进程，恢复失败"
              echo "restore_success=false" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            sleep $RETRY_INTERVAL
          done
          sudo umount /var/lib/docker/* 2>/dev/null || true
          sync && sleep 5
          
          # 检测快照完整性（增加大小校验）
          echo "✅ 检测快照完整性..."
          SNAPSHOT_REMOTE_SIZE=$(rclone size mywebdav:${SNAPSHOT_PATH} --config $RCLONE_CONF_PATH | grep "Total size" | awk '{print $3$4}')
          if ! rclone cat mywebdav:${SNAPSHOT_PATH} --config $RCLONE_CONF_PATH | head -c 1024 >/dev/null 2>&1 || [[ $SNAPSHOT_REMOTE_SIZE == "0"* ]]; then
            echo "❌ 快照文件损坏或为空，恢复失败"
            echo "restore_success=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          # 下载并恢复快照（使用pigz加速解压）
          echo "✅ 快照大小：$SNAPSHOT_REMOTE_SIZE，开始下载并恢复..."
          TEMP_SNAPSHOT="$TMP_DIR/$(basename $SNAPSHOT_PATH)"
          rclone cat mywebdav:${SNAPSHOT_PATH} --config $RCLONE_CONF_PATH > "$TEMP_SNAPSHOT"
          
          # 校验本地文件大小
          LOCAL_SIZE=$(du -sh "$TEMP_SNAPSHOT" | awk '{print $1}')
          if [[ $(stat -c%s "$TEMP_SNAPSHOT") -lt 102400 ]]; then
            echo "❌ 本地快照文件过小，恢复失败"
            echo "restore_success=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          # 优化解压参数，提升速度
          sudo tar -I pigz -xf "$TEMP_SNAPSHOT" -C / \
            --overwrite \
            --ignore-failed-read \
            -p \
            --same-owner \
            --preserve-links \
            --acls \
            --xattrs
          rm -f "$TEMP_SNAPSHOT"
          
          # 修复权限（模块化）
          echo "✅ 修复Docker+TTA全目录权限..."
          sudo chown -R root:root \
            /var/lib/docker /etc/docker /etc/containerd /usr/bin/docker* /usr/bin/containerd* /usr/bin/ctr \
            /usr/lib/systemd/system/docker* /usr/lib/systemd/system/containerd.service /etc/systemd/system/docker.service.d \
            /TTA
          sudo chmod -R 755 \
            /var/lib/docker /etc/docker /etc/containerd /usr/bin/docker* /usr/bin/containerd* /usr/bin/ctr \
            /TTA
          sudo chmod 644 /usr/lib/systemd/system/docker* /usr/lib/systemd/system/containerd.service /etc/crictl.yaml
          sudo chmod 700 /var/lib/docker /var/run/docker /var/run/containerd
          
          # 重新加载配置并验证
          sudo systemctl daemon-reload
          sudo systemctl reset-failed docker containerd docker.socket 2>/dev/null || true
          
          if ! /usr/bin/docker --version >/dev/null 2>&1; then
            echo "❌ Docker二进制文件损坏，恢复失败"
            echo "restore_success=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          # 优化：保留最近3个快照，而非全部删除
          echo "✅ 清理旧快照（保留最近$KEEP_SNAPSHOTS个）..."
          ALL_SNAPSHOTS=$(rclone ls mywebdav:${WEBDAV_SNAPSHOT_DIR_CLEAN} --config $RCLONE_CONF_PATH \
            | grep "docker-tta-full-snapshot-.*.tar.gz" | awk -F '/' '{print $NF}' | sort -r)
          SNAPSHOTS_TO_DELETE=$(echo "$ALL_SNAPSHOTS" | tail -n +$((KEEP_SNAPSHOTS + 1)))
          for snap in $SNAPSHOTS_TO_DELETE; do
            sudo rclone delete mywebdav:${WEBDAV_SNAPSHOT_DIR_CLEAN}/$snap --config $RCLONE_CONF_PATH
            sudo rclone delete mywebdav:${WEBDAV_SNAPSHOT_DIR_CLEAN}/docker-tta-snapshot-meta-${snap%.tar.gz}.txt --config $RCLONE_CONF_PATH
          done
          
          echo "✅ Docker+TTA快照1:1恢复完成，可直接启动Docker"
          echo "restore_success=true" >> "$GITHUB_OUTPUT"

      - name: 5. Clean Docker Residues (Restore Failed)
        if: ${{ steps.restore.outputs.restore_success != 'true' }}
        run: |
          set -euo pipefail
          echo "===== 清理Docker所有残留 ====="
          # 强制停止+彻底卸载
          sudo systemctl stop docker containerd docker.socket 2>/dev/null || true
          sudo pkill -9 docker containerd ctr dockerd 2>/dev/null || true
          sudo apt purge -y docker* moby* containerd* runc* docker-compose-plugin* -y || true
          sudo apt autoremove -y --purge && sudo apt clean
          
          # 删除Docker相关目录（保留/TTA）
          sudo rm -rf /var/lib/docker /etc/docker /etc/containerd /usr/bin/docker* /usr/bin/containerd* \
            /usr/lib/systemd/system/docker* /usr/lib/systemd/system/containerd.service \
            /etc/systemd/system/docker.service.d /var/run/docker /var/run/containerd /etc/crictl.yaml \
            /usr/share/keyrings/docker-* /etc/apt/sources.list.d/docker.list 2>/dev/null || true
          
          echo "✅ Docker残留清理完成，/TTA目录已保留"

      - name: 6. Install Official Docker (Full Version, No Snapshot)
        if: ${{ steps.restore.outputs.restore_success != 'true' }}
        id: docker-install
        run: |
          set -euo pipefail
          echo "===== 安装官方完整Docker ====="
          
          # 配置Docker官方源（带重试）
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            if curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ Docker GPG密钥下载失败" && exit 1
            fi
            sleep $RETRY_INTERVAL
          done
          
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
            $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list >/dev/null
          
          # 安装Docker组件
          sudo apt update -y && sudo apt install -y \
            docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-buildx-plugin
          
          # 优化Docker配置
          sudo mkdir -p /etc/docker
          cat <<EOF | sudo tee /etc/docker/daemon.json
          {
            "log-driver": "json-file",
            "log-opts": {"max-size": "$DOCKER_LOG_MAX_SIZE", "max-file": "$DOCKER_LOG_MAX_FILE"},
            "registry-mirrors": ["$DOCKER_REGISTRY_MIRROR"],
            "insecure-registries": [],
            "storage-driver": "overlay2",
            "max-concurrent-downloads": 10,
            "max-concurrent-uploads": 5
          }
          EOF
          
          # 配置开机自启+权限
          sudo systemctl enable --now docker containerd docker.socket
          sudo usermod -aG docker runner
          sudo chmod 666 /var/run/docker.sock 2>/dev/null || true
          
          # 验证Docker完整性（带重试）
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            if sudo systemctl is-active --quiet docker && docker compose version >/dev/null 2>&1 && containerd -v >/dev/null 2>&1; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ Docker安装失败，服务无法启动"
              sudo systemctl status docker --no-pager
              exit 1
            fi
            sudo systemctl restart docker
            sleep $RETRY_INTERVAL
          done
          
          echo "✅ 官方完整Docker安装完成："
          echo "Docker 版本：$(docker -v)"
          echo "Docker Compose 版本：$(docker compose version | head -n1)"
          echo "Containerd 版本：$(containerd -v)"
          echo "restore_success=true" >> "$GITHUB_OUTPUT"

      - name: 7. Start Docker & Full Verify
        if: ${{ steps.restore.outputs.restore_success == 'true' || steps.docker-install.outputs.restore_success == 'true' }}
        run: |
          set -euo pipefail
          echo "===== 启动Docker并验证完整性 ====="
          
          # 启动Docker服务（带重试）
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            sudo systemctl enable --now docker containerd docker.socket
            if sudo systemctl is-active --quiet docker; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ Docker服务启动失败"
              sudo systemctl status docker --no-pager
              sudo journalctl -u docker --no-pager | tail -30
              exit 1
            fi
            sleep $RETRY_INTERVAL
          done
          sleep 8
          
          # 多维度验证
          echo "✅ 验证Docker命令可用性..."
          if ! docker info >/dev/null 2>&1; then
            echo "❌ Docker命令执行失败" && exit 1
          fi
          
          echo "✅ 创建测试容器..."
          if ! docker run --rm alpine echo "Docker Test Success"; then
            echo "❌ Docker无法创建容器"
            docker ps -a
            docker system df
            exit 1
          fi
          
          echo "✅ 验证网络/存储..."
          sudo docker network ls >/dev/null 2>&1 && echo "✅ Docker网络正常"
          sudo docker volume create test-volume >/dev/null 2>&1 && sudo docker volume rm test-volume >/dev/null 2>&1 && echo "✅ Docker存储正常"
          
          # 验证TTA目录
          [ -d "/TTA" ] && echo "✅ /TTA目录存在且完整" || (sudo mkdir -p /TTA && echo "✅ /TTA目录已自动创建")
          
          # 清理测试残留
          sudo docker system prune -f 2>/dev/null || true
          
          echo "✅ Docker+TTA全量验证通过！"
          echo "✅ 当前Docker状态：$(docker info | grep -E 'Server Version|Containers:|Images:|Storage Driver')"

      - name: 8. Deploy Tailscale (Optional)
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.TAILSCALE_AUTH_KEY }}" ]; then
            echo "ℹ️ 未配置Tailscale密钥，跳过部署"
            exit 0
          fi
          
          # 安装Tailscale（带重试）
          for ((i=1; i<=$RETRY_TIMES; i++)); do
            if curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/$OS_VERSION.noarmor.gpg | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg; then
              break
            elif [ $i -eq $RETRY_TIMES ]; then
              echo "❌ Tailscale GPG密钥下载失败" && exit 0
            fi
            sleep $RETRY_INTERVAL
          done
          
          echo "deb [signed-by=/usr/share/keyrings/tailscale-archive-keyring.gpg] https://pkgs.tailscale.com/stable/ubuntu $OS_VERSION main" | sudo tee /etc/apt/sources.list.d/tailscale.list
          sudo apt update -y && sudo apt install -y tailscale
          
          # 启动Tailscale（支持自定义网段）
          sudo tailscale up --authkey="${{ secrets.TAILSCALE_AUTH_KEY }}" \
            --accept-routes --hostname="docker-tta-snapshot-${{ github.run_id }}" \
            --advertise-routes=172.17.0.0/16,172.18.0.0/16,192.168.0.0/16
          
          echo "✅ Tailscale部署完成，内网IP：$(sudo tailscale ip -4)"

      - name: 9. Create Docker+TTA Full Snapshot + Upload WebDAV + Auto Renew
        if: ${{ steps.webdav-config.outputs.webdav_available == 'true' }}
        run: |
          set -euo pipefail
          start_time=$(date +%s)
          RENEW_TRIGGERED=false
          echo "===== 启动Docker+TTA全量快照流程 ====="
          
          # 重试函数封装
          retry_command() {
            local cmd="$1"
            local retries=$2
            local interval=$3
            for ((i=1; i<=$retries; i++)); do
              if eval "$cmd"; then
                return 0
              elif [ $i -eq $retries ]; then
                echo "❌ 命令执行失败：$cmd"
                return 1
              fi
              sleep $interval
            done
          }
          
          # 续跑函数（优化：增加剩余时间判断）
          trigger_renew() {
            if [ -z "${{ secrets.USER_PAT }}" ]; then
              echo "❌ 未配置GitHub PAT，无法触发续跑"
              return 1
            fi
            
            # 剩余时间不足30分钟才触发续跑
            current_time=$(date +%s)
            elapsed_mins=$(( (current_time - start_time) / 60 ))
            remaining_mins=$(( MAX_RUN_MINUTES - elapsed_mins ))
            if [ $remaining_mins -gt 30 ]; then
              echo "ℹ️ 剩余时间充足（$remaining_mins分钟），无需续跑"
              return 0
            fi
            
            echo "✅ 剩余时间不足30分钟，触发新续跑..."
            CURRENT_RUN_ID="${{ github.run_id }}"
            CURRENT_REPO="${{ github.repository }}"
            
            # 终止当前工作流（带重试）
            retry_command "curl -fsSL -X POST \
              -H \"Authorization: token ${{ secrets.USER_PAT }}\" \
              -H \"Accept: application/vnd.github.v3+json\" \
              \"https://api.github.com/repos/$CURRENT_REPO/actions/runs/$CURRENT_RUN_ID/cancel\"" $RETRY_TIMES $RETRY_INTERVAL
            
            # 触发新续跑（带重试）
            if retry_command "curl -fsSL --fail -X POST \
              -H \"Authorization: token ${{ secrets.USER_PAT }}\" \
              -H \"Accept: application/vnd.github.v3+json\" \
              -H \"Content-Type: application/json\" \
              \"https://api.github.com/repos/$CURRENT_REPO/dispatches\" \
              -d '{\"event_type\":\"renew_docker_tta_snapshot\"}'" $RETRY_TIMES $RETRY_INTERVAL; then
              RENEW_TRIGGERED=true
              echo "✅ 新续跑工作流已启动"
            else
              echo "❌ 续跑触发失败"
            fi
          }
          
          # 创建快照函数（优化：先清理Docker缓存）
          create_docker_tta_snapshot() {
            # 过滤有效目录
            VALID_DIRS=""
            for dir in $DOCKER_TTA_FULL_DIRS; do
              if [ -d "$dir" ] || [ -f "$dir" ]; then
                VALID_DIRS="$VALID_DIRS $dir"
              else
                echo "ℹ️ 跳过不存在的目录：$dir"
              fi
            done
            if [ -z "$VALID_DIRS" ]; then
              echo "❌ 无有效目录可备份"
              return 1
            fi
            
            # 快照命名
            SNAPSHOT_NAME="docker-tta-full-snapshot-$(date +%Y%m%d-%H%M%S).tar.gz"
            TMP_SNAPSHOT="$TMP_DIR/$SNAPSHOT_NAME"
            REMOTE_PATH="mywebdav:${WEBDAV_SNAPSHOT_DIR_CLEAN}/$SNAPSHOT_NAME"
            
            # 停止Docker+清理缓存
            echo "✅ 停止Docker服务，清理缓存..."
            sudo systemctl stop docker containerd docker.socket 2>/dev/null || true
            sudo pkill -9 docker containerd ctr dockerd 2>/dev/null || true
            sudo docker system prune -af 2>/dev/null || true  # 清理缓存（停止前尝试）
            sync && sleep 5
            
            # 打包快照（使用pigz加速，增加进度显示）
            echo "✅ 开始创建快照（保留权限/软链接）..."
            if ! sudo tar -I pigz -czpf "$TMP_SNAPSHOT" \
              --overwrite \
              -p \
              --same-owner \
              --preserve-links \
              --acls \
              --xattrs \
              --numeric-owner \
              $EXCLUDE_RULES \
              $VALID_DIRS; then
              echo "❌ 快照打包失败"
              sudo systemctl start docker containerd docker.socket
              return 1
            fi
            
            # 校验快照
            if [ $(stat -c%s "$TMP_SNAPSHOT") -lt 102400 ]; then
              echo "❌ 快照文件过小（<100KB）"
              rm -f "$TMP_SNAPSHOT"
              sudo systemctl start docker containerd docker.socket
              return 1
            fi
            SNAPSHOT_SIZE=$(du -sh "$TMP_SNAPSHOT" | awk '{print $1}')
            SNAPSHOT_MD5=$(md5sum "$TMP_SNAPSHOT" | awk '{print $1}')
            
            # 上传快照（多线程+重试）
            echo "✅ 快照大小：$SNAPSHOT_SIZE，开始上传WebDAV..."
            if ! retry_command "rclone copy \"$TMP_SNAPSHOT\" \"$REMOTE_PATH\" --config $RCLONE_CONF_PATH --transfers $RCLONE_TRANSFERS --multi-thread-streams 2" $RETRY_TIMES $RETRY_INTERVAL; then
              echo "❌ 快照上传失败"
              rm -f "$TMP_SNAPSHOT"
              sudo systemctl start docker containerd docker.socket
              return 1
            fi
            
            # 生成元数据（包含MD5）
            echo "✅ 生成快照元数据..."
            META_FILE="$TMP_DIR/docker-tta-snapshot-meta-${SNAPSHOT_NAME%.tar.gz}.txt"
            printf "snapshot_name=%s\ncreate_time=%s\ncreate_host=%s\ndocker_version=%s\ncontainerd_version=%s\ndocker_compose_version=%s\nsnapshot_size=%s\nsnapshot_md5=%s\nexclude_rules=%s\nbackup_dirs=Docker全核心+/TTA\nta_dir=/TTA\n" \
              "$SNAPSHOT_NAME" \
              "$(date +%Y-%m-%d\ %H:%M:%S\ %Z)" \
              "$(hostname -f)" \
              "$(docker -v 2>/dev/null | awk '{print $3}' | sed 's/,//g' || echo 'unknown')" \
              "$(containerd -v 2>/dev/null | awk '{print $3}' | sed 's/v//g' || echo 'unknown')" \
              "$(docker compose version 2>/dev/null | head -n1 | awk '{print $4}' | sed 's/,//g' || echo 'unknown')" \
              "$SNAPSHOT_SIZE" \
              "$SNAPSHOT_MD5" \
              "$EXCLUDE_RULES" | sudo tee "$META_FILE"
            
            # 上传元数据
            rclone copy "$META_FILE" mywebdav:${WEBDAV_SNAPSHOT_DIR_CLEAN}/ --config $RCLONE_CONF_PATH
            
            # 清理+重启Docker
            rm -f "$TMP_SNAPSHOT" "$META_FILE"
            sudo systemctl start docker containerd docker.socket
            sleep 5
            
            # 验证Docker重启
            if ! sudo systemctl is-active --quiet docker; then
              echo "⚠️ Docker重启失败，尝试修复..."
              sudo systemctl restart docker
            fi
            
            echo "✅ 快照创建完成：$SNAPSHOT_NAME (MD5: $SNAPSHOT_MD5)"
            return 0
          }
          
          # 主循环（优化：更精准的超时判断）
          while true; do
            current_time=$(date +%s)
            elapsed_mins=$(( (current_time - start_time) / 60 ))
            remaining_mins=$(( MAX_RUN_MINUTES - elapsed_mins ))
            
            echo "⏱️ 运行时间：$elapsed_mins / $MAX_RUN_MINUTES 分钟（剩余：$remaining_mins 分钟）"
            
            # 运行2分钟后创建快照（仅一次）
            if [ $elapsed_mins -ge 2 ] && [ "$RENEW_TRIGGERED" = "false" ]; then
              if create_docker_tta_snapshot; then
                trigger_renew
              else
                echo "❌ 快照创建失败，退出循环"
                break
              fi
            fi
            
            # 超时退出
            if [ $elapsed_mins -ge $MAX_RUN_MINUTES ]; then
              echo "⏹️ 工作流超时，正常退出"
              exit 0
            fi
            
            sleep 60
          done

      - name: 10. Clean All Temp Files (Always Execute)
        if: ${{ always() }}
        run: |
          set -euo pipefail
          echo "===== 清理所有临时文件 ====="
          
          # 清理临时文件
          sudo rm -rf $TMP_DIR $RCLONE_CONF_PATH /etc/sudoers.d/runner /tmp/rclone_*.log 2>/dev/null || true
          
          # 清理apt缓存
          sudo apt clean && sudo apt autoremove -y 2>/dev/null || true
          
          # 保证Docker运行+TTA目录完整
          sudo systemctl start docker containerd docker.socket 2>/dev/null || true
          sudo systemctl unmask docker.socket containerd.service 2>/dev/null || true
          [ ! -d "/TTA" ] && sudo mkdir -p /TTA
          
          # 最终验证
          if sudo systemctl is-active --quiet docker && [ -d "/TTA" ]; then
            echo "✅ 清理完成，Docker运行正常，/TTA目录完整"
          else
            echo "⚠️ 清理完成，尝试修复Docker/TTA..."
            sudo systemctl restart docker
          fi
